From 01aba581118913b727cede1707803c32e6f7a109 Mon Sep 17 00:00:00 2001
From: Stefan Lippers-Hollmann <s.l-h@gmx.de>
Date: Mon, 1 Jul 2013 02:27:53 +0200
Subject: [PATCH 19/65] acerhk: Use pr_<fmt> and pr_<level>

Use the current logging styles.

Make sure all output has a prefix.
Add missing newlines.

Signed-off-by: Stefan Lippers-Hollmann <s.l-h@gmx.de>
---
 drivers/platform/x86/acerhk.c | 568 ++++++++++++++++++++++--------------------
 1 file changed, 295 insertions(+), 273 deletions(-)

--- a/drivers/platform/x86/acerhk.c
+++ b/drivers/platform/x86/acerhk.c
@@ -42,6 +42,8 @@
  */
 #ifdef CONFIG_X86
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/version.h>
 #include <linux/moduleparam.h>
 
@@ -194,7 +196,8 @@ static void send_kbd_cmd(unsigned char c
 static void enable_wlan_ec_1(void)
 {
 	if (verbose)
-		printk(KERN_INFO "acerhk: enabling WLAN via EC variant 1\n");
+		pr_info("enabling WLAN via EC variant 1\n");
+
 	send_kbd_cmd(0xe7, 0x01);
 	acerhk_wlan_state = 1;
 }
@@ -202,7 +205,8 @@ static void enable_wlan_ec_1(void)
 static void disable_wlan_ec_1(void)
 {
 	if (verbose)
-		printk(KERN_INFO "acerhk: disabling WLAN via EC variant 1\n");
+		pr_info("disabling WLAN via EC variant 1\n");
+
 	send_kbd_cmd(0xe7, 0x00);
 	acerhk_wlan_state = 0;
 }
@@ -210,8 +214,8 @@ static void disable_wlan_ec_1(void)
 static void enable_bluetooth_ec_1(void)
 {
 	if (verbose)
-		printk(KERN_INFO
-		       "acerhk: enabling Bluetooth via EC variant 1\n");
+		pr_info("enabling Bluetooth via EC variant 1\n");
+
 	send_kbd_cmd(0xe7, 0x03);
 	acerhk_bluetooth_state = 1;
 }
@@ -219,8 +223,8 @@ static void enable_bluetooth_ec_1(void)
 static void disable_bluetooth_ec_1(void)
 {
 	if (verbose)
-		printk(KERN_INFO
-		       "acerhk: disabling Bluetooth via EC variant 1\n");
+		pr_info("disabling Bluetooth via EC variant 1\n");
+
 	send_kbd_cmd(0xe7, 0x02);
 	acerhk_bluetooth_state = 0;
 }
@@ -228,7 +232,8 @@ static void disable_bluetooth_ec_1(void)
 static void enable_wlan_ec_2(void)
 {
 	if (verbose)
-		printk(KERN_INFO "acerhk: enabling WLAN via EC variant 2\n");
+		pr_info("enabling WLAN via EC variant 2\n");
+
 	send_kbd_cmd(0x45, acerhk_bluetooth_state ? 0xa2 : 0xa0);
 	acerhk_wlan_state = 1;
 }
@@ -236,7 +241,8 @@ static void enable_wlan_ec_2(void)
 static void disable_wlan_ec_2(void)
 {
 	if (verbose)
-		printk(KERN_INFO "acerhk: disabling WLAN via EC variant 2\n");
+		pr_info("disabling WLAN via EC variant 2\n");
+
 	send_kbd_cmd(0x45, acerhk_bluetooth_state ? 0xa1 : 0xa3);
 	acerhk_wlan_state = 0;
 }
@@ -244,8 +250,8 @@ static void disable_wlan_ec_2(void)
 static void enable_bluetooth_ec_2(void)
 {
 	if (verbose)
-		printk(KERN_INFO
-		       "acerhk: enabling Bluetooth via EC variant 2\n");
+		pr_info("enabling Bluetooth via EC variant 2\n");
+
 	send_kbd_cmd(0x45, acerhk_wlan_state ? 0xa2 : 0xa1);
 	acerhk_bluetooth_state = 1;
 }
@@ -253,8 +259,8 @@ static void enable_bluetooth_ec_2(void)
 static void disable_bluetooth_ec_2(void)
 {
 	if (verbose)
-		printk(KERN_INFO
-		       "acerhk: disabling Bluetooth via EC variant 2\n");
+		pr_info("disabling Bluetooth via EC variant 2\n");
+
 	send_kbd_cmd(0x45, acerhk_wlan_state ? 0xa0 : 0xa3);
 	acerhk_bluetooth_state = 0;
 }
@@ -262,59 +268,60 @@ static void disable_bluetooth_ec_2(void)
 static void enable_dritek_keyboard(void)
 {
 	if (verbose)
-		printk(KERN_INFO
-		       "acerhk: enabling dritek keyboard extension\n");
+		pr_info("enabling dritek keyboard extension\n");
+
 	send_kbd_cmd(0x59, 0x90);
 }
 
 static void disable_dritek_keyboard(void)
 {
 	if (verbose)
-		printk(KERN_INFO
-		       "acerhk: disabling dritek keyboard extension\n");
+		pr_info("disabling dritek keyboard extension\n");
+
 	send_kbd_cmd(0x59, 0x91);
 }
 
 static void enable_mail_led_ec_1(void)
 {
 	if (verbose)
-		printk(KERN_INFO
-		       "acerhk: enabling mail led via EC variant 1\n");
+		pr_info("enabling mail led via EC variant 1\n");
+
 	send_kbd_cmd(0xe8, 0x01);
 }
 
 static void disable_mail_led_ec_1(void)
 {
 	if (verbose)
-		printk(KERN_INFO
-		       "acerhk: disabling mail led via EC variant 1\n");
+		pr_info("disabling mail led via EC variant 1\n");
+
 	send_kbd_cmd(0xe8, 0x00);
 }
 
 static void enable_mail_led_ec_2(void)
 {
 	if (verbose)
-		printk(KERN_INFO
-		       "acerhk: enabling mail led via EC variant 2\n");
+		pr_info("enabling mail led via EC variant 2\n");
+
 	send_kbd_cmd(0x59, 0x92);
 }
 
 static void disable_mail_led_ec_2(void)
 {
 	if (verbose)
-		printk(KERN_INFO
-		       "acerhk: disabling mail led via EC variant 2\n");
+		pr_info("disabling mail led via EC variant 2\n");
+
 	send_kbd_cmd(0x59, 0x93);
 }
 
 static void enable_mail_led_ec_3(void)
 {
 	if (verbose)
-		printk(KERN_INFO
-		       "acerhk:  enabling mail led via EC variant 3\n");
+		pr_info("enabling mail led via EC variant 3\n");
+
 	preempt_disable();
 	if (!my_i8042_wait_write())
 		outl(0x80008894, 0xCF8);
+
 	if (!my_i8042_wait_write())
 		outw(0xC061, 0xCFC);
 	preempt_enable_no_resched();
@@ -323,11 +330,12 @@ static void enable_mail_led_ec_3(void)
 static void disable_mail_led_ec_3(void)
 {
 	if (verbose)
-		printk(KERN_INFO
-		       "acerhk:  disabling mail led via EC variant 3\n");
+		pr_info("disabling mail led via EC variant 3\n");
+
 	preempt_disable();
 	if (!my_i8042_wait_write())
 		outl(0x80008894, 0xCF8);
+
 	if (!my_i8042_wait_write())
 		outw(0xC060, 0xCFC);
 	preempt_enable_no_resched();
@@ -467,9 +475,10 @@ static asmlinkage void call_bios_6xx(str
 }
 
 #define PRINT_BUFFER(x) \
-  printk(KERN_INFO"acerhk: eax=0x%x ebx=0x%x ecx=0x%x edx=0x%x\n" \
-		 "acerhk: edi=0x%x esi=0x%x ebp=0x%x\n", \
-		 x.eax, x.ebx, x.ecx, x.edx, x.edi, x.esi, x.ebp);
+	pr_info("eax=0x%x ebx=0x%x ecx=0x%x edx=0x%x\n" \
+		"%s: edi=0x%x esi=0x%x ebp=0x%x\n", \
+		x.eax, x.ebx, x.ecx, x.edx, \
+		KBUILD_MODNAME, x.edi, x.esi, x.ebp);
 
 /* get_fnkey_event
  *
@@ -506,14 +515,14 @@ static int get_thermal_event(void)
 		preempt_disable();
 		call_bios(&regs);
 		preempt_enable_no_resched();
+
 		if (verbose > 3)
-			printk(KERN_INFO "acerhk: thermal event = 0x%x\n",
-			       regs.eax);
+			pr_info("thermal event = 0x%x\n", regs.eax);
 	} else {
 		regs.eax = 0x00;
+
 		if (verbose > 3)
-			printk(KERN_INFO
-			       "acerhk: thermal event not supported\n");
+			pr_info("thermal event not supported\n");
 	}
 	return regs.eax & 0xffff;
 }
@@ -535,15 +544,17 @@ static int wbutton_fct_1(int val)
 		acerhk_bluetooth_state = val;
 		regs.eax = 0x9610;
 		regs.ebx = ((val & 0xff) << 8) | 0x34;
+
 		preempt_disable();
 		call_bios(&regs);
 		preempt_enable_no_resched();
+
 		if (verbose > 3)
-			printk(KERN_INFO "acerhk: wbutton1 = 0x%x\n", regs.eax);
+			pr_info("wbutton1 = 0x%x\n", regs.eax);
 	} else {
 		if (verbose > 3)
-			printk(KERN_INFO
-			       "acerhk: wbutton function 1 not supported\n");
+			pr_info("wbutton function 1 not supported\n");
+
 		regs.eax = 0x00;
 	}
 	return regs.eax & 0xffff;
@@ -565,15 +576,17 @@ static int wbutton_fct_2(int val)
 		acerhk_wlan_state = val;
 		regs.eax = 0x9610;
 		regs.ebx = ((val & 0xff) << 8) | 0x35;
+
 		preempt_disable();
 		call_bios(&regs);
 		preempt_enable_no_resched();
+
 		if (verbose > 3)
-			printk(KERN_INFO "acerhk: wbutton2 = 0x%x\n", regs.eax);
+			pr_info("wbutton2 = 0x%x\n", regs.eax);
 	} else {
 		if (verbose > 3)
-			printk(KERN_INFO
-			       "acerhk: wbutton function 2 not supported\n");
+			pr_info("wbutton function 2 not supported\n");
+
 		regs.eax = 0x00;
 	}
 	return regs.eax & 0xffff;
@@ -592,13 +605,16 @@ static int get_cmos_index(void)
 	struct register_buffer regs;
 	regs.eax = 0x9610;
 	regs.ebx = 0x51C;
+
 	preempt_disable();
 	call_bios(&regs);
 	preempt_enable_no_resched();
+
 	cmos_index = regs.ecx & 0xff;
+
 	if (verbose)
-		printk(KERN_INFO "acerhk: cmos index set to 0x%x\n",
-		       cmos_index);
+		pr_info("cmos index set to 0x%x\n", cmos_index);
+
 	return cmos_index;
 }
 #endif
@@ -620,8 +636,7 @@ static int get_nr_events(void)
 	if (cmos_index)
 		c = CMOS_READ(cmos_index);
 	else if (verbose > 3)
-		printk(KERN_INFO
-		       "acerhk: get_nr_events - no valid cmos index set\n");
+		pr_info("get_nr_events - no valid cmos index set\n");
 #endif
 	spin_unlock_irqrestore(&rtc_lock, flags);
 	return c;
@@ -643,12 +658,13 @@ static int set_mail_led(int val)
 	if (acerhk_model_features & TM_F_MAIL_LED) {
 		regs.eax = 0x9610;
 		regs.ebx = ((val & 0xff) << 8) | 0x31;
+
 		preempt_disable();
 		call_bios(&regs);
 		preempt_enable_no_resched();
+
 		if (verbose > 3)
-			printk(KERN_INFO "acerhk: mail led set to = 0x%x\n",
-			       val);
+			pr_info("mail led set to = 0x%x\n", val);
 	} else if (acerhk_model_features & TM_F_MAIL_LED_EC) {
 		if (val == 1)
 			enable_mail_led_ec_1();
@@ -666,9 +682,11 @@ static int set_mail_led(int val)
 			disable_mail_led_ec_3();
 	} else {
 		if (verbose > 3)
-			printk(KERN_INFO "acerhk: mail led not supported\n");
+			pr_info("mail led not supported\n");
+
 		regs.eax = 0x00;
 	}
+
 	return regs.eax & 0xffff;
 }
 
@@ -680,20 +698,24 @@ static int set_mail_led(int val)
 static int launch_connect(int val)
 {
 	struct register_buffer regs;
+
 	if (acerhk_model_features & TM_F_CONNECT) {
 		regs.eax = 0x9610;
 		regs.ebx = ((val & 0xff) << 8) | 0x2e;
+
 		preempt_disable();
 		call_bios(&regs);
 		preempt_enable_no_resched();
+
 		if (verbose > 3)
-			printk(KERN_INFO "acerhk: connect(%d) = 0x%x\n", val,
-			       regs.eax);
+			pr_info("connect(%d) = 0x%x\n", val, regs.eax);
 	} else {
 		if (verbose > 3)
-			printk(KERN_INFO "acerhk: connect not supported\n");
+			pr_info("connect not supported\n");
+
 		regs.eax = 0x00;
 	}
+
 	return regs.eax & 0xffff;
 }
 
@@ -710,6 +732,7 @@ static unsigned long __init find_hk_area
 	unsigned int fkt;
 	fkt = 0;
 	sig = -1;		/* offset to signature in io area */
+
 	/* Look for signature, start at 0xf0000, search until 0xffff0 */
 	for (offset = 0; offset < 0xfffd; offset += 16) {
 		if (readl(reg1 + offset) == 0x30552142) {
@@ -717,9 +740,9 @@ static unsigned long __init find_hk_area
 			offset = 0xffff;
 		}
 	}
+
 	if (sig < 0)
-		printk(KERN_WARNING
-		       "acerhk: could not find request handler, possibly not all functions available\n");
+		pr_warn("could not find request handler, possibly not all functions available\n");
 	else {
 		/* compute location of bios routine */
 		fkt = readl(reg1 + sig + 5);
@@ -738,107 +761,111 @@ static unsigned long __init find_hk_area
 static void print_features(void)
 {
 	int i;
-	printk(KERN_INFO "acerhk: supported keys:");
+
+	pr_info("supported keys:");
 	for (i = 0; i < 255; i++) {
 		switch (acerhk_key2name[i]) {
 		case k_help:
-			printk(" help");
+			printk(KERN_INFO " help");
 			break;
 		case k_setup:
-			printk(" setup");
+			printk(KERN_INFO " setup");
 			break;
 		case k_p1:
-			printk(" p1");
+			printk(KERN_INFO " p1");
 			break;
 		case k_p2:
-			printk(" p2");
+			printk(KERN_INFO " p2");
 			break;
 		case k_p3:
-			printk(" p3");
+			printk(KERN_INFO " p3");
 			break;
 		case k_www:
-			printk(" www");
+			printk(KERN_INFO " www");
 			break;
 		case k_mail:
-			printk(" mail");
+			printk(KERN_INFO " mail");
 			break;
 		case k_wireless:
-			printk(" wireless");
+			printk(KERN_INFO " wireless");
 			break;
 		case k_power:
-			printk(" power");
+			printk(KERN_INFO " power");
 			break;
 		case k_mute:
-			printk(" mute");
+			printk(KERN_INFO " mute");
 			break;
 		case k_volup:
-			printk(" volup");
+			printk(KERN_INFO " volup");
 			break;
 		case k_voldn:
-			printk(" voldn");
+			printk(KERN_INFO " voldn");
 			break;
 		case k_res:
-			printk(" res");
+			printk(KERN_INFO " res");
 			break;
 		case k_close:
-			printk(" close");
+			printk(KERN_INFO " close");
 			break;
 		case k_open:
-			printk(" open");
+			printk(KERN_INFO " open");
 			break;
 		case k_wireless2:
-			printk(" wireless2");
+			printk(KERN_INFO " wireless2");
 			break;
 		case k_play:
-			printk(" play");
+			printk(KERN_INFO " play");
 			break;
 		case k_stop:
-			printk(" stop");
+			printk(KERN_INFO " stop");
 			break;
 		case k_prev:
-			printk(" prev");
+			printk(KERN_INFO " prev");
 			break;
 		case k_next:
-			printk(" next");
+			printk(KERN_INFO " next");
 			break;
 		case k_display:
-			printk(" display");
+			printk(KERN_INFO " display");
 			break;
 		default:
 			break;
 		}
 	}
-	printk("\n");
+	printk(KERN_INFO "\n");
+
 	if (acerhk_model_features & TM_F_MUTE_LED_EC)
-		printk(KERN_INFO "acerhk: mute led is supported\n");
+		pr_info("mute led is supported\n");
+
 	if (acerhk_model_features & TM_F_MAIL_LED)
-		printk(KERN_INFO "acerhk: mail led is supported\n");
+		pr_info("mail led is supported\n");
 	else if (acerhk_model_features & TM_F_MAIL_LED_EC)
-		printk(KERN_INFO "acerhk: mail led (EC) is supported\n");
+		pr_info("mail led (EC) is supported\n");
 	else if (acerhk_model_features & TM_F_MAIL_LED_EC2)
-		printk(KERN_INFO "acerhk: mail led (EC2) is supported\n");
+		pr_info("mail led (EC2) is supported\n");
 	else if (acerhk_model_features & TM_F_MAIL_LED_EC3)
-		printk(KERN_INFO "acerhk: mail led (EC3) is supported\n");
+		pr_info("mail led (EC3) is supported\n");
+
 	if (acerhk_model_features & TM_F_WLAN_EC1)
-		printk(KERN_INFO "acerhk: wlan control (EC1) is supported\n");
+		pr_info("wlan control (EC1) is supported\n");
 	else if (acerhk_model_features & TM_F_WLAN_EC2)
-		printk(KERN_INFO "acerhk: wlan control (EC2) is supported\n");
+		pr_info("wlan control (EC2) is supported\n");
+
 	if (acerhk_model_features & TM_F_BLUE_EC1)
-		printk(KERN_INFO
-		       "acerhk: bluetooth control (EC1) is supported\n");
+		pr_info("bluetooth control (EC1) is supported\n");
 	else if (acerhk_model_features & TM_F_BLUE_EC2)
-		printk(KERN_INFO
-		       "acerhk: bluetooth control (EC2) is supported\n");
-	printk(KERN_INFO "acerhk: supported functions:");
+		pr_info("bluetooth control (EC2) is supported\n");
+
+	pr_info("supported functions:");
 	if (acerhk_model_features & TM_F_CONNECT)
-		printk(" connect");
+		printk(KERN_INFO " connect");
 	if (acerhk_model_features & TM_F_THERMAL)
-		printk(" thermal");
+		printk(KERN_INFO " thermal");
 	if (acerhk_model_features & TM_F_PBUTTON)
-		printk(" pbutton");
+		printk(KERN_INFO " pbutton");
 	if (acerhk_model_features & TM_F_WBUTTON)
-		printk(" wbutton");
-	printk("\n");
+		printk(KERN_INFO " wbutton");
+	printk(KERN_INFO "\n");
 }
 
 static void __init setup_keymap_model(unsigned int series)
@@ -994,14 +1021,16 @@ static void __init setup_model_features(
 	}
 	/* set the correct bios call function according to type */
 	call_bios = call_bios_6xx;
+
 	if (verbose > 2)
-		printk(KERN_INFO "acerhk: using call_bios_6xx mode\n");
+		pr_info("using call_bios_6xx mode\n");
 
 	/* remove key file on dritek hardware */
 	remove_proc_entry("key", proc_acer_dir);
 
 	/* setup available keys */
 	setup_keymap_model(acerhk_series);
+
 	if (verbose > 1)
 		print_features();
 }
@@ -1033,8 +1062,7 @@ static unsigned int __init determine_lap
 					break;
 				default:
 					if (verbose > 1)
-						printk(KERN_INFO
-						       "acerhk: model string indicates unknown TM 2xxx series\n");
+						pr_info("model string indicates unknown TM 2xxx series\n");
 					break;
 				}
 			}
@@ -1047,8 +1075,7 @@ static unsigned int __init determine_lap
 				/* Travelmate 3xx series */
 			default:
 				if (verbose > 1)
-					printk(KERN_INFO
-					       "acerhk: model string indicates unknown TM 3xx series\n");
+					pr_info("model string indicates unknown TM 3xx series\n");
 				break;
 			}
 			break;
@@ -1061,8 +1088,7 @@ static unsigned int __init determine_lap
 					break;
 				default:
 					if (verbose > 1)
-						printk(KERN_INFO
-						       "acerhk: model string indicates unknown TM 4xxx series\n");
+						pr_info("model string indicates unknown TM 4xxx series\n");
 					break;
 				}
 			} else {	/* Travelmate 4xx series */
@@ -1075,8 +1101,7 @@ static unsigned int __init determine_lap
 					break;
 				default:
 					if (verbose > 1)
-						printk(KERN_INFO
-						       "acerhk: model string indicates unknown TM 4xx series\n");
+						pr_info("model string indicates unknown TM 4xx series\n");
 					break;
 				}
 			}
@@ -1085,20 +1110,18 @@ static unsigned int __init determine_lap
 			switch (str[12]) {
 			default:
 				if (verbose > 1)
-					printk(KERN_INFO
-					       "acerhk: model string indicates unknown TM 6xx series\n");
+					pr_info("model string indicates unknown TM 6xx series\n");
 				break;
 			}
 			break;
 		default:
-			printk(KERN_INFO
-			       "acerhk: model string indicates unknown TM xxx series\n");
+			pr_info("model string indicates unknown TM xxx series\n");
 			break;
 		}
+
 		if (series && verbose > 1)
-			printk(KERN_INFO
-			       "acerhk: model string indicates TM %d series\n",
-			       series);
+			pr_info("model string indicates TM %d series\n",
+				series);
 	}
 	/* newer Travelmate series do not have a space after 'TravelMate' */
 	else if (strncmp(str, "TravelMate", 10) == 0) {
@@ -1108,8 +1131,7 @@ static unsigned int __init determine_lap
 				series = 290;
 			} else {
 				if (verbose > 1)
-					printk(KERN_INFO
-					       "acerhk: model string indicates unknown TM2xx series\n");
+					pr_info("model string indicates unknown TM2xx series\n");
 			}
 			break;
 		case '3':
@@ -1118,8 +1140,7 @@ static unsigned int __init determine_lap
 				series = 3200;
 			} else {
 				if (verbose > 1)
-					printk(KERN_INFO
-					       "acerhk: model string indicates unknown TM3xxx series\n");
+					pr_info("model string indicates unknown TM3xxx series\n");
 			}
 			break;
 		case '4':
@@ -1129,8 +1150,7 @@ static unsigned int __init determine_lap
 				break;
 			default:
 				if (verbose > 1)
-					printk(KERN_INFO
-					       "acerhk: model string indicates unknown TM4xx series\n");
+					pr_info("model string indicates unknown TM4xx series\n");
 				break;
 			}
 			break;
@@ -1144,8 +1164,7 @@ static unsigned int __init determine_lap
 				break;
 			default:
 				if (verbose > 1)
-					printk(KERN_INFO
-					       "acerhk: model string indicates unknown TM5xx series\n");
+					pr_info("model string indicates unknown TM5xx series\n");
 				break;
 			}
 			break;
@@ -1164,8 +1183,7 @@ static unsigned int __init determine_lap
 				}
 			default:
 				if (verbose > 1)
-					printk(KERN_INFO
-					       "acerhk: model string indicates unknown TM6xx series\n");
+					pr_info("model string indicates unknown TM6xx series\n");
 				break;
 			}
 			break;
@@ -1176,19 +1194,15 @@ static unsigned int __init determine_lap
 				series = 800;
 			} else {
 				if (verbose > 1)
-					printk(KERN_INFO
-					       "acerhk: model string indicates unknown TM8xx series\n");
+					pr_info("model string indicates unknown TM8xx series\n");
 			}
 			break;
 		default:
-			printk(KERN_INFO
-			       "acerhk: model string indicates unknown TMxxx series\n");
+			pr_info("model string indicates unknown TMxxx series\n");
 			break;
 		}
 		if (series && verbose > 1)
-			printk(KERN_INFO
-			       "acerhk: model string indicates TM%d series\n",
-			       series);
+			pr_info("model string indicates TM%d series\n", series);
 	} else if (strncmp(str, "Aspire ", 7) == 0) {
 		switch (str[7]) {
 		case '1':	/* Aspire 1xxx series */
@@ -1209,8 +1223,7 @@ static unsigned int __init determine_lap
 					break;
 				default:
 					if (verbose > 1)
-						printk(KERN_INFO
-						       "acerhk: model string indicates unknown Aspire 13xx series\n");
+						pr_info("model string indicates unknown Aspire 13xx series\n");
 					break;
 				}
 				break;
@@ -1224,8 +1237,7 @@ static unsigned int __init determine_lap
 					break;
 				default:
 					if (verbose > 1)
-						printk(KERN_INFO
-						       "acerhk: model string indicates unknown Aspire 14xx series\n");
+						pr_info("model string indicates unknown Aspire 14xx series\n");
 					break;
 				}
 				break;
@@ -1237,8 +1249,7 @@ static unsigned int __init determine_lap
 				break;
 			default:
 				if (verbose > 1)
-					printk(KERN_INFO
-					       "acerhk: model string indicates unknown Aspire 1xxx series\n");
+					pr_info("model string indicates unknown Aspire 1xxx series\n");
 				break;
 			}
 			break;
@@ -1247,8 +1258,7 @@ static unsigned int __init determine_lap
 				switch (str[9]) {
 				default:
 					if (verbose > 1)
-						printk(KERN_INFO
-						       "acerhk: model string indicates unknown Aspire 20xx series\n");
+						pr_info("model string indicates unknown Aspire 20xx series\n");
 					break;
 				case '0':
 					series = 2000;
@@ -1262,8 +1272,7 @@ static unsigned int __init determine_lap
 				}
 			} else {
 				if (verbose > 1)
-					printk(KERN_INFO
-					       "acerhk: model string indicates unknown Aspire 2xxx series\n");
+					pr_info("model string indicates unknown Aspire 2xxx series\n");
 			}
 			break;
 		case '3':	/* Aspire 3xxx series */
@@ -1271,14 +1280,12 @@ static unsigned int __init determine_lap
 				switch (str[9]) {
 				default:
 					if (verbose > 1)
-						printk(KERN_INFO
-						       "acerhk: model string indicates unknown Aspire 30xx series\n");
+						pr_info("model string indicates unknown Aspire 30xx series\n");
 					break;
 				}
 			} else {
 				if (verbose > 1)
-					printk(KERN_INFO
-					       "acerhk: model string indicates unknown Aspire 3xxx series\n");
+					pr_info("model string indicates unknown Aspire 3xxx series\n");
 			}
 			break;
 		case '5':	/* Aspire 5xxx series */
@@ -1286,28 +1293,24 @@ static unsigned int __init determine_lap
 				switch (str[9]) {
 				default:
 					if (verbose > 1)
-						printk(KERN_INFO
-						       "acerhk: model string indicates unknown Aspire 50xx series\n");
+						pr_info("model string indicates unknown Aspire 50xx series\n");
 					break;
 				}
 			} else if (str[8] == '1' && str[9] == '0') {
 				series = 5100;
 			} else {
 				if (verbose > 1)
-					printk(KERN_INFO
-					       "acerhk: model string indicates unknown Aspire 5xxx series\n");
+					pr_info("model string indicates unknown Aspire 5xxx series\n");
 			}
 			break;
 		default:
 			if (verbose > 1)
-				printk(KERN_INFO
-				       "acerhk: model string indicates unknown Aspire series\n");
+				pr_info("model string indicates unknown Aspire series\n");
 			break;
 		}
 		if (series && verbose > 1)
-			printk(KERN_INFO
-			       "acerhk: model string indicates Aspire %d series\n",
-			       series);
+			pr_info("model string indicates Aspire %d series\n",
+				series);
 	} else if (strncmp(str, "Extensa ", 8) == 0) {
 		/* Extensa series */
 		switch (str[8]) {
@@ -1324,34 +1327,28 @@ static unsigned int __init determine_lap
 			break;
 		}
 		if (series && verbose > 1)
-			printk(KERN_INFO
-			       "acerhk: model string indicates Extensa %d series\n",
-			       series);
+			pr_info("model string indicates Extensa %d series\n",
+				series);
 		else if (verbose > 1)
-			printk(KERN_INFO
-			       "acerhk: model string indicates unknown Extensa series\n");
+			pr_info("model string indicates unknown Extensa series\n");
 	} else if (strncmp(str, "Amilo ", 6) == 0) {
 		switch (str[6]) {
 		default:
 			if (verbose > 1)
-				printk(KERN_INFO
-				       "acerhk: model string indicates unknown FS Amilo XX series\n");
+				pr_info("model string indicates unknown FS Amilo XX series\n");
 		}
 	} else if (strncmp(str, "MEDIONPC", 8) == 0) {
 		if (verbose > 1)
-			printk(KERN_INFO
-			       "acerhk: model string indicates a medion MD %d\n",
-			       series);
+			pr_info("model string indicates a medion MD %d\n",
+				series);
 	} else if (strncmp(str, "MEDIONNB", 8) == 0) {
 		if (verbose > 1)
-			printk(KERN_INFO
-			       "acerhk: model string indicates no supported Medion hardware\n");
+			pr_info("model string indicates no supported Medion hardware\n");
 	} else if (strncmp(str, "AOpen", 5) == 0) {
 		/* Unless I know of other models no further differentiation,
 		   although there is a second part of the model string */
 		if (verbose > 1)
-			printk(KERN_INFO
-			       "acerhk: model string indicates a AOpen\n");
+			pr_info("model string indicates a AOpen\n");
 	} else if (strncmp(str, "CL56", 4) == 0) {
 		/* Unless I know of other models no further differentiation,
 		   although there are strings with more numbers ("CL561" on a Compal
@@ -1359,19 +1356,16 @@ static unsigned int __init determine_lap
 		   It has the same functions as Acer Aspire 2010
 		 */
 		if (verbose > 1)
-			printk(KERN_INFO
-			       "acerhk: model string indicates a Compal CL56 (or similar)\n");
+			pr_info("model string indicates a Compal CL56 (or similar)\n");
 		series = 2010;
 	} else if (strncmp(str, "Geneva2", 7) == 0) {
 		/* This might be an Aspire 9110 which is very similar to 4650 */
 		if (verbose > 1)
-			printk(KERN_INFO
-			       "acerhk: model string indicates an Aspire 9110\n");
+			pr_info("model string indicates an Aspire 9110\n");
 		series = 4650;
 	} else {
 		if (verbose > 1)
-			printk(KERN_INFO
-			       "acerhk: model string indicates no supported hardware\n");
+			pr_info("model string indicates no supported hardware\n");
 	}
 	return (series);
 }
@@ -1381,48 +1375,57 @@ static unsigned int __init determine_lap
 static void __init probe_model(void)
 {
 	int offset;		/* offset from beginning of reg1 to Model string */
+
 	if (verbose)
-		printk(KERN_INFO
-		       "acerhk: start search for model string at %p\n", reg1);
+		pr_info("start search for model string at %p\n", reg1);
+
 	/* first we look for Travelmate, if it isn't one we try to identify other
 	   laptops, such as Medion or Aspire */
 	offset = COLUSSI("Travel", 6, reg1, AREA_SIZE);
+
 	/* Try to detect Aspire laptops */
 	if (offset < 0)
 		offset = COLUSSI("Aspire", 6, reg1, AREA_SIZE);
 	/* Try to detect Extensa laptops */
+
 	if (offset < 0)
 		offset = COLUSSI("Extensa", 7, reg1, AREA_SIZE);
+
 	/* Try to detect Medion laptops */
 	if (offset < 0)
 		offset = COLUSSI("MEDION", 6, reg1, AREA_SIZE);
 	/* Try to detect AOpen laptops */
+
 	if (offset < 0)
 		offset = COLUSSI("AOpen", 5, reg1, AREA_SIZE);
+
 	/* Try to detect Fujitsu Siemens Amilo laptops */
 	if (offset < 0)
 		offset = COLUSSI("Amilo", 5, reg1, AREA_SIZE);
 	if (offset < 0)
 		offset = COLUSSI("AMILO", 5, reg1, AREA_SIZE);
+
 	/* Try to detect Compal */
 	if (offset < 0)
 		offset = COLUSSI("CL56", 4, reg1, AREA_SIZE);
+
 	/* That might be an Aspire 9110 */
 	if (offset < 0)
 		offset = COLUSSI("Geneva2", 7, reg1, AREA_SIZE);
+
 	if (offset >= 0) {
 		acerhk_model_addr = reg1 + offset;
 		/* copy the string, but not more than 15 characters */
 		strncpy(acerhk_model_string, acerhk_model_addr,
 			ACERHK_MODEL_STRLEN - 1);
 		if (verbose)
-			printk(KERN_INFO
-			       "acerhk: found model string '%s' at %p\n",
-			       acerhk_model_string, acerhk_model_addr);
+			pr_info("found model string '%s' at %p\n",
+				acerhk_model_string, acerhk_model_addr);
+
 		if (bios_routine && verbose > 2)
-			printk(KERN_INFO
-			       "acerhk: offset from model string to function address: 0x%lx\n",
-			       bios_routine - (unsigned long)acerhk_model_addr);
+			pr_info("offset from model string to function address: 0x%lx\n",
+				bios_routine - (unsigned long)acerhk_model_addr);
+
 		acerhk_series = determine_laptop_series(acerhk_model_string);
 	}
 }
@@ -1434,28 +1437,28 @@ static void __init probe_model(void)
 
 static void print_mapping(void)
 {
-	printk(KERN_INFO "acerhk: key mapping:\n");
-	printk("acerhk: help     0x%x\n", acerhk_name2event[k_help]);
-	printk("acerhk: setup    0x%x\n", acerhk_name2event[k_setup]);
-	printk("acerhk: p1       0x%x\n", acerhk_name2event[k_p1]);
-	printk("acerhk: p2       0x%x\n", acerhk_name2event[k_p2]);
-	printk("acerhk: p3       0x%x\n", acerhk_name2event[k_p3]);
-	printk("acerhk: www      0x%x\n", acerhk_name2event[k_www]);
-	printk("acerhk: mail     0x%x\n", acerhk_name2event[k_mail]);
-	printk("acerhk: wireless 0x%x\n", acerhk_name2event[k_wireless]);
-	printk("acerhk: power    0x%x\n", acerhk_name2event[k_power]);
-	printk("acerhk: mute     0x%x\n", acerhk_name2event[k_mute]);
-	printk("acerhk: volup    0x%x\n", acerhk_name2event[k_volup]);
-	printk("acerhk: voldn    0x%x\n", acerhk_name2event[k_voldn]);
-	printk("acerhk: res      0x%x\n", acerhk_name2event[k_res]);
-	printk("acerhk: close    0x%x\n", acerhk_name2event[k_close]);
-	printk("acerhk: open     0x%x\n", acerhk_name2event[k_open]);
-	printk("acerhk: wireless2 0x%x\n", acerhk_name2event[k_wireless2]);
-	printk("acerhk: play     0x%x\n", acerhk_name2event[k_play]);
-	printk("acerhk: stop     0x%x\n", acerhk_name2event[k_stop]);
-	printk("acerhk: prev     0x%x\n", acerhk_name2event[k_prev]);
-	printk("acerhk: next     0x%x\n", acerhk_name2event[k_next]);
-	printk("acerhk: display  0x%x\n", acerhk_name2event[k_display]);
+	pr_info("key mapping:\n");
+	pr_info("help      0x%x\n", acerhk_name2event[k_help]);
+	pr_info("setup     0x%x\n", acerhk_name2event[k_setup]);
+	pr_info("p1        0x%x\n", acerhk_name2event[k_p1]);
+	pr_info("p2        0x%x\n", acerhk_name2event[k_p2]);
+	pr_info("p3        0x%x\n", acerhk_name2event[k_p3]);
+	pr_info("www       0x%x\n", acerhk_name2event[k_www]);
+	pr_info("mail      0x%x\n", acerhk_name2event[k_mail]);
+	pr_info("wireless  0x%x\n", acerhk_name2event[k_wireless]);
+	pr_info("power     0x%x\n", acerhk_name2event[k_power]);
+	pr_info("mute      0x%x\n", acerhk_name2event[k_mute]);
+	pr_info("volup     0x%x\n", acerhk_name2event[k_volup]);
+	pr_info("voldn     0x%x\n", acerhk_name2event[k_voldn]);
+	pr_info("res       0x%x\n", acerhk_name2event[k_res]);
+	pr_info("close     0x%x\n", acerhk_name2event[k_close]);
+	pr_info("open      0x%x\n", acerhk_name2event[k_open]);
+	pr_info("wireless2 0x%x\n", acerhk_name2event[k_wireless2]);
+	pr_info("play      0x%x\n", acerhk_name2event[k_play]);
+	pr_info("stop      0x%x\n", acerhk_name2event[k_stop]);
+	pr_info("prev      0x%x\n", acerhk_name2event[k_prev]);
+	pr_info("next      0x%x\n", acerhk_name2event[k_next]);
+	pr_info("display   0x%x\n", acerhk_name2event[k_display]);
 }
 
 static void set_keymap_name(t_key_names name, unsigned int key)
@@ -1499,13 +1502,15 @@ static void init_keymap_input(void)
 static int filter_idle_value(int keycode)
 {
 	int validkey = 0;
+
 	if (keycode != 0x0 && keycode != 0x9610 && keycode != 0xc100 &&	/* Francois Valenduc, Aspire 1601 LC */
 	    keycode != 0x8610 &&
 	    keycode != 0x861 && keycode != 0x8650 && keycode != 0x865)
 		validkey = keycode;
+
 	if (verbose > 4 && !validkey)
-		printk(KERN_INFO "acerhk: throw away idle value 0x%x\n",
-		       keycode);
+		pr_info("throw away idle value 0x%x\n", keycode);
+
 	return validkey;
 }
 #endif
@@ -1514,13 +1519,15 @@ static int filter_idle_value(int keycode
 static void send_key_event(t_key_names key)
 {
 	unsigned int input_key;
+
 	if (key != k_none) {
 		/* convert key name to kernel keycode */
 		input_key = acerhk_name2event[key];
+
 		if (verbose > 2)
-			printk(KERN_INFO
-			       "acerhk: translated acer key name 0x%x to input key 0x%x\n",
-			       key, input_key);
+			pr_info("translated acer key name 0x%x to input key 0x%x\n",
+				key, input_key);
+
 		/* send press and release together, as there is no such event from acer as 'release' */
 		input_report_key(acerhk_input_dev_ptr, input_key, 1);
 		input_report_key(acerhk_input_dev_ptr, input_key, 0);
@@ -1532,31 +1539,31 @@ static void send_key_event(t_key_names k
 static t_key_names transl8_key_code(int keycode)
 {
 	t_key_names keyname = k_none;
+
 	/* first filter out idle values */
 	if ((keycode = filter_idle_value(keycode))) {
 		if (verbose > 3)
-			printk(KERN_INFO "acerhk: received key code 0x%x\n",
-			       keycode);
+			pr_info("received key code 0x%x\n", keycode);
+
 		/* translate keycode to key name */
 		if (keycode >= 0 && keycode <= 255)
 			keyname = acerhk_key2name[keycode];
 		else {
 			if (verbose > 3)
-				printk(KERN_INFO
-				       "acerhk: keycode 0x%x too big, will use only 8 bits\n",
+				pr_info("keycode 0x%x too big, will use only 8 bits\n",
 				       keycode);
+
 			/* use only lower 8 bits of value to distinguish keys */
 			keyname = acerhk_key2name[keycode & 0xff];
 		}
 		/* produce some log information for higher verbosity levels */
 		if (keyname != k_none && verbose > 2)
-			printk(KERN_INFO
-			       "acerhk: translated acer key code 0x%x to key name 0x%x\n",
-			       keycode, keyname);
+			pr_info("translated acer key code 0x%x to key name 0x%x\n",
+				keycode, keyname);
 		else if (keyname == k_none && verbose > 3)
-			printk(KERN_INFO
-			       "acerhk: translated acer key code 0x%x to no key\n",
-			       keycode);
+			pr_info("translated acer key code 0x%x to no key\n",
+				keycode);
+
 		if (autowlan) {
 			/* if automatic switching of wlan hardware is enabled, do it here
 			   on wireless key press */
@@ -1566,6 +1573,7 @@ static t_key_names transl8_key_code(int
 				else
 					wbutton_fct_1(1);
 			}
+
 			if (keyname == k_wireless) {
 				if (acerhk_wlan_state)
 					wbutton_fct_2(0);
@@ -1604,8 +1612,7 @@ static void acerhk_blink_event(unsigned
 		    jiffies + acerhk_blueled_blinking_delay;
 		add_timer(&acerhk_timer_blinking);
 	} else
-		printk(KERN_WARNING
-		       "acerhk: blinking event called, but blinking not active\n");
+		pr_warn("blinking event called, but blinking not active\n");
 }
 
 static void init_input(void)
@@ -1624,6 +1631,7 @@ static void init_input(void)
 
 	/* some laptops have a mail led, should I announce it here? */
 	acerhk_input_dev_ptr->evbit[0] = BIT(EV_KEY);
+
 	/* announce keys to input system
 	 * the generated keys can be changed on runtime,
 	 * but to publish those changes the device needs to
@@ -1633,8 +1641,10 @@ static void init_input(void)
 		set_bit(i, acerhk_input_dev_ptr->keybit);
 	/* set mapping keyname -> input event */
 	init_keymap_input();
+
 	if (verbose)
-		printk(KERN_INFO "acerhk: registered input device\n");
+		pr_info("registered input device\n");
+
 	input_register_device(acerhk_input_dev_ptr);
 	init_timer(&acerhk_timer_poll);
 	acerhk_polling_state = 0;
@@ -1644,11 +1654,13 @@ static void stop_polling(void)
 {
 	if (acerhk_polling_state == 1) {
 		del_timer(&acerhk_timer_poll);
+
 		if (verbose)
-			printk(KERN_INFO "acerhk: key polling stopped\n");
+			pr_info("key polling stopped\n");
+
 		acerhk_polling_state = 0;
 	} else if (verbose)
-		printk(KERN_INFO "acerhk: key polling not active\n");
+		pr_info("key polling not active\n");
 }
 
 static void start_polling(void)
@@ -1659,17 +1671,16 @@ static void start_polling(void)
 		acerhk_timer_poll.data = get_nr_events();
 		add_timer(&acerhk_timer_poll);
 		acerhk_polling_state = 1;
-		printk(KERN_INFO
-		       "acerhk: Your hardware does not need polling enabled for hotkeys to work, "
-		       "you can safely disable polling by using the module parameter poll=0 (unless you "
-		       "want to play around with the driver and see if there are buttons which need polling).\n");
+
+		pr_info("Your hardware does not need polling enabled for hotkeys to work, "
+			"you can safely disable polling by using the module parameter poll=0 (unless you "
+			"want to play around with the driver and see if there are buttons which need polling).\n");
 
 		if (verbose)
-			printk(KERN_INFO
-			       "acerhk: starting key polling, every %d ms\n",
-			       acerhk_polling_delay);
+			pr_info("starting key polling, every %d ms\n",
+				acerhk_polling_delay);
 	} else if (verbose)
-		printk(KERN_INFO "acerhk: key polling already active\n");
+		pr_info("key polling already active\n");
 }
 
 /* addedd by Antonio Cuni */
@@ -1683,10 +1694,11 @@ static void start_blinking(void)
 		acerhk_timer_blinking.data = 0;	// not used
 		add_timer(&acerhk_timer_blinking);
 		acerhk_blueled_blinking = 0;
+
 		if (verbose)
-			printk(KERN_INFO "acerhk: starting blueled blinking\n");
+			pr_info("starting blueled blinking\n");
 	} else if (verbose)
-		printk(KERN_INFO "acerhk: blueled already blinking\n");
+		pr_info("blueled already blinking\n");
 }
 
 /* Added by Antonio Cuni */
@@ -1694,8 +1706,10 @@ static void stop_blinking(void)
 {
 	if (acerhk_blueled_blinking != -1) {
 		del_timer(&acerhk_timer_blinking);
+
 		if (verbose)
-			printk(KERN_INFO "acerhk: blueled blinking stopped\n");
+			pr_info("blueled blinking stopped\n");
+
 		acerhk_blueled_blinking = -1;
 	}
 }
@@ -1874,18 +1888,18 @@ static int acerhk_proc_blueled(struct fi
 	if (isNumber && acerhk_blueled_blinking_delay != 0
 	    && acerhk_blueled_blinking_delay != 1) {
 		if (acerhk_blueled_blinking_delay < 50)
-			printk(KERN_INFO
-			       "acerhk: blinking request rejected. The delay must be > 50.\n");
+			pr_info("blinking request rejected. The delay must be > 50.\n");
 		else {
 			if (verbose)
-				printk(KERN_INFO
-				       "acerhk: blinking delay set to %u.\n",
-				       acerhk_blueled_blinking_delay);
+				pr_info("blinking delay set to %u.\n",
+					acerhk_blueled_blinking_delay);
+
 			start_blinking();
 		}
 	} else if (acerhk_blueled_blinking_delay == 1 || !strncmp(str, "on", 2)
 		   || !strncmp(str, "an", 2)) {
 		stop_blinking();
+
 		if (acerhk_model_features & TM_F_BLUE_EC1)
 			enable_bluetooth_ec_1();
 		else if (acerhk_model_features & TM_F_BLUE_EC2)
@@ -1914,15 +1928,15 @@ static int acerhk_proc_init(void)
 	proc_acer_dir = proc_mkdir("driver/acerhk", NULL);
 	if (proc_acer_dir == NULL) {
 		retval = 0;
-		printk(KERN_INFO
-		       "acerhk: could not create /proc/driver/acerhk\n");
+		pr_info("could not create /proc/driver/acerhk\n");
 	} else {
 		/* now create several files, first general info ... */
 		entry = create_proc_read_entry("info",
 					       0444, proc_acer_dir,
 					       acerhk_proc_info, NULL);
+
 		if (entry == NULL) {
-			printk(KERN_INFO "acerhk: cannot create info file\n");
+			pr_info("cannot create info file\n");
 			remove_proc_entry("driver/acerhk", NULL);
 			retval = 0;
 		} else {
@@ -1931,8 +1945,7 @@ static int acerhk_proc_init(void)
 						       0444, proc_acer_dir,
 						       acerhk_proc_key, NULL);
 			if (entry == NULL) {
-				printk(KERN_INFO
-				       "acerhk: cannot create key file\n");
+				pr_info("cannot create key file\n");
 				remove_proc_entry("info", proc_acer_dir);
 				remove_proc_entry("driver/acerhk", NULL);
 				retval = 0;
@@ -1942,8 +1955,7 @@ static int acerhk_proc_init(void)
 				    create_proc_entry("led", 0222,
 						      proc_acer_dir);
 				if (entry == NULL) {
-					printk(KERN_INFO
-					       "acerhk: cannot create LED file\n");
+					pr_info("cannot create LED file\n");
 					remove_proc_entry("info",
 							  proc_acer_dir);
 					remove_proc_entry("key", proc_acer_dir);
@@ -1958,8 +1970,7 @@ static int acerhk_proc_init(void)
 							      0222,
 							      proc_acer_dir);
 					if (entry == NULL) {
-						printk(KERN_INFO
-						       "acerhk: cannot create wirelessled file\n");
+						pr_info("cannot create wirelessled file\n");
 						remove_proc_entry("info",
 								  proc_acer_dir);
 						remove_proc_entry("key",
@@ -1978,8 +1989,7 @@ static int acerhk_proc_init(void)
 								      0222,
 								      proc_acer_dir);
 						if (entry == NULL) {
-							printk(KERN_INFO
-							       "acerhk: cannot create blueled file\n");
+							pr_info("cannot create blueled file\n");
 							remove_proc_entry
 							    ("info",
 							     proc_acer_dir);
@@ -2094,8 +2104,7 @@ static long acerhk_unlocked_ioctl(struct
 			retval = -EFAULT;
 		else {
 			if (verbose) {
-				printk(KERN_INFO
-				       "acerhk: changed key mapping\n");
+				pr_info("changed key mapping\n");
 				print_mapping();
 			}
 			retval = 0;
@@ -2121,7 +2130,7 @@ static int acerhk_release(struct inode *
 #ifdef CONFIG_PM
 static int acerhk_resume(struct platform_device *dev)
 {
-	printk(KERN_INFO "acerhk: Resuming. Setting wlan_state to: %d\n",
+	pr_info("Resuming. Setting wlan_state to: %d\n",
 	       acerhk_wlan_state);
 
 	if (acerhk_wlan_state)
@@ -2153,19 +2162,23 @@ static void __devinit model_init(void)
 {
 	/* set callroutine, features and keymap for model */
 	setup_model_features(acerhk_series);
+
 	/* override initial state of wireless hardware if specified by module options */
 	if (wlan_state >= 0)
 		acerhk_wlan_state = wlan_state;
+
 	if (bluetooth_state >= 0)
 		acerhk_bluetooth_state = bluetooth_state;
+
 	/* Launch connect only if available */
 	if (acerhk_model_features & TM_F_CONNECT) {
 		if (verbose)
-			printk(KERN_INFO
-			       "acerhk: Model type dritek, calling launch_connect(1)\n");
+			pr_info("Model type dritek, calling launch_connect(1)\n");
+
 		launch_connect(1);
 	}
 	enable_dritek_keyboard();
+
 	/* added by Antonio Cuni */
 	init_timer(&acerhk_timer_blinking);
 }
@@ -2179,42 +2192,46 @@ static int __devinit acerhk_probe(struct
 
 	ret = misc_register(&acerhk_misc_dev);
 	if (ret) {
-		printk(KERN_ERR "acerhk: can't misc_register on minor=%d\n",
-		       ACERHK_MINOR);
+		pr_err("can't misc_register on minor=%d\n", ACERHK_MINOR);
 		ret = -EAGAIN;
 	} else if (!acerhk_proc_init()) {
-		printk(KERN_ERR "acerhk: can't create procfs entries\n");
+		pr_err("can't create procfs entries\n");
 		ret = -ENOMEM;
 		misc_deregister(&acerhk_misc_dev);
 	} else {
 		reg1 = ioremap(0xf0000, 0xffff);
 		if (verbose > 1)
-			printk(KERN_INFO
-			       "acerhk: area from 0xf000 to 0xffff mapped to %p\n",
-			       reg1);
+			pr_info("area from 0xf000 to 0xffff mapped to %p\n",
+				reg1);
+
 		reg2 = ioremap(0xe0000, 0xffff);
 		if (verbose > 1)
-			printk(KERN_INFO
-			       "acerhk: area from 0xe000 to 0xffff mapped to %p\n",
-			       reg2);
+			pr_info("area from 0xe000 to 0xffff mapped to %p\n",
+				reg2);
+
 		/* attach to input system */
 		init_input();
 		memset(acerhk_model_string, 0x00, ACERHK_MODEL_STRLEN);
 #ifdef __x86_64__
 		acerhk_model_addr = (void *)0x12345678;
+
 		/* copy the string, but not more than 15 characters */
 		strncpy(acerhk_model_string, "TravelmateDummy",
 			ACERHK_MODEL_STRLEN - 1);
+
 		/* set callroutine for model */
 		if (force_series)
 			acerhk_series = force_series;
 		else
 			acerhk_series = 2000;
+
 		setup_model_features(acerhk_series);
-		printk(KERN_INFO "Acer Travelmate hotkey driver dummy\n");
+		pr_info("Acer Travelmate hotkey driver dummy\n");
 		enable_dritek_keyboard();
+
 		if (poll)
 			start_polling();
+
 		init_timer(&acerhk_timer_blinking);
 #else
 		bios_routine = find_hk_area();
@@ -2222,28 +2239,30 @@ static int __devinit acerhk_probe(struct
 			probe_model();
 		else {
 			if (verbose)
-				printk(KERN_INFO
-				       "acerhk: forced laptop series to %d\n",
-				       force_series);
+				pr_info("forced laptop series to %d\n",
+					force_series);
+
 			acerhk_series = force_series;
 		}
+
 		/* do model specific initialization */
 		model_init();
+
 		/* Without a bios routine we cannot do anything except on dritek
 		   type HW, unload on other types */
 		ret = 0;
 		if (verbose && bios_routine)
-			printk(KERN_INFO
-			       "acerhk: bios routine found at 0x%x\n",
-			       bios_routine);
-		printk(KERN_INFO "Acer Travelmate hotkey driver\n");
+			pr_info("bios routine found at 0x%x\n", bios_routine);
+
+		pr_info("Acer Travelmate hotkey driver\n");
+
 		/* If automatic switching of wlan is wanted but polling is disabled,
 		   automatically enable it */
 		if (!poll && autowlan) {
-			printk(KERN_INFO
-			       "Automatic switching of wireless hardware needs polling, enabling it\n");
+			pr_info("Automatic switching of wireless hardware needs polling, enabling it\n");
 			poll = 1;
 		}
+
 		/* start automatic polling of key presses if wanted and bios routine found */
 		if (poll && bios_routine)
 			start_polling();
@@ -2256,15 +2275,19 @@ static int __devexit acerhk_remove(struc
 {
 	acerhk_proc_cleanup();
 	stop_blinking();
+
 	if (reg1)
 		iounmap(reg1);
+
 	if (reg2)
 		iounmap(reg2);
+
 	release_input();
 	misc_deregister(&acerhk_misc_dev);
 	disable_dritek_keyboard();
+
 	if (verbose > 2)
-		printk(KERN_INFO "acerhk: unloaded\n");
+		pr_info("unloaded\n");
 
 	return 0;
 }
@@ -2314,7 +2337,7 @@ static void __exit acerhk_exit(void)
 {
 	platform_device_unregister(acerhk_platform_device);
 	platform_driver_unregister(&acerhk_driver);
-	printk(KERN_INFO "acerhk: removed.\n");
+	pr_info("removed.\n");
 }
 
 module_init(acerhk_init);
@@ -2325,7 +2348,6 @@ MODULE_AUTHOR("Stefan Lippers-Hollmann <
 MODULE_DESCRIPTION("AcerHotkeys extra buttons keyboard driver");
 MODULE_LICENSE("GPL");
 
-
 #else
 #error This driver is only available for X86 architecture
 #endif
