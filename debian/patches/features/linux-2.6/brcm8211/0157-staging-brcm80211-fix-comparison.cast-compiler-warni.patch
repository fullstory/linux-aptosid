commit 53e974db655da7df6f1ac5db8da94cbeb288ab35
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Sun Oct 10 14:07:09 2010 -0400

    staging: brcm80211: fix 'comparison..cast' compiler warnings.
    
    Use min_t() macro instead of min().
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
@@ -1664,7 +1664,7 @@ static int dhd_ioctl_entry(struct net_de
 
 	/* Copy out any buffer passed */
 	if (ioc.buf) {
-		buflen = min(ioc.len, DHD_IOCTL_MAXLEN);
+		buflen = min_t(int, ioc.len, DHD_IOCTL_MAXLEN);
 		/* optimization for direct ioctl calls from kernel */
 		/*
 		   if (segment_eq(get_fs(), KERNEL_DS)) {
--- a/drivers/staging/brcm80211/brcmfmac/wl_iw.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.c
@@ -690,7 +690,7 @@ wl_iw_set_spy(struct net_device *dev,
 	if (!extra)
 		return -EINVAL;
 
-	iw->spy_num = min(ARRAY_SIZE(iw->spy_addr), dwrq->length);
+	iw->spy_num = min_t(int, ARRAY_SIZE(iw->spy_addr), dwrq->length);
 	for (i = 0; i < iw->spy_num; i++)
 		memcpy(&iw->spy_addr[i], addr[i].sa_data, ETHER_ADDR_LEN);
 	memset(iw->spy_qual, 0, sizeof(iw->spy_qual));
@@ -1280,9 +1280,9 @@ wl_iw_set_scan(struct net_device *dev,
 					__func__, req->essid));
 				return -EBUSY;
 			} else {
-				g_specific_ssid.SSID_len =
-				    min(sizeof(g_specific_ssid.SSID),
-					req->essid_len);
+				g_specific_ssid.SSID_len = min_t(unsigned char,
+						sizeof(g_specific_ssid.SSID),
+						req->essid_len);
 				memcpy(g_specific_ssid.SSID, req->essid,
 				       g_specific_ssid.SSID_len);
 				g_specific_ssid.SSID_len =
@@ -1379,7 +1379,8 @@ wl_iw_iscan_set_scan(struct net_device *
 	if (wrqu->data.length == sizeof(struct iw_scan_req)) {
 		if (wrqu->data.flags & IW_SCAN_THIS_ESSID) {
 			struct iw_scan_req *req = (struct iw_scan_req *)extra;
-			ssid.SSID_len = min(sizeof(ssid.SSID), req->essid_len);
+			ssid.SSID_len = min_t(unsigned char, sizeof(ssid.SSID),
+						req->essid_len);
 			memcpy(ssid.SSID, req->essid, ssid.SSID_len);
 			ssid.SSID_len = htod32(ssid.SSID_len);
 		} else {
@@ -1906,9 +1907,11 @@ wl_iw_set_essid(struct net_device *dev,
 
 	if (dwrq->length && extra) {
 #if WIRELESS_EXT > 20
-		g_ssid.SSID_len = min(sizeof(g_ssid.SSID), dwrq->length);
+		g_ssid.SSID_len = min_t(unsigned char, sizeof(g_ssid.SSID),
+					dwrq->length);
 #else
-		g_ssid.SSID_len = min(sizeof(g_ssid.SSID), dwrq->length - 1);
+		g_ssid.SSID_len = min_t(unsigned char, sizeof(g_ssid.SSID),
+					dwrq->length - 1);
 #endif
 		memcpy(g_ssid.SSID, extra, g_ssid.SSID_len);
 	} else {
@@ -2441,7 +2444,7 @@ wl_iw_get_encode(struct net_device *dev,
 
 	wsec = dtoh32(wsec);
 	auth = dtoh32(auth);
-	dwrq->length = min(DOT11_MAX_KEY_SIZE, key.len);
+	dwrq->length = min_t(u16, DOT11_MAX_KEY_SIZE, key.len);
 
 	dwrq->flags = key.index + 1;
 	if (!(wsec & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED)))
