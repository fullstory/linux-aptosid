Apply the equivalent of:

#commit 8318d78a44d49ac1edf2bdec7299de3617c4232e
#Author: Johannes Berg <johannes@sipsolutions.net>
#Date:   Thu Jan 24 19:38:38 2008 +0100
#
#    cfg80211 API for channels/bitrates, mac80211 and driver conversion
#
#    This patch creates new cfg80211 wiphy API for channel and bitrate
#    registration and converts mac80211 and drivers to the new API. The
#    old mac80211 API is completely ripped out. All drivers (except ath5k)
#    are updated to the new API, in many cases I expect that optimisations
#    can be done.
#
#    Along with the regulatory code I've also ripped out the
#    IEEE80211_HW_DEFAULT_REG_DOMAIN_CONFIGURED flag, I believe it to be
#    unnecessary if the hardware simply gives us whatever channels it wants
#    to support and we then enable/disable them as required, which is pretty
#    much required for travelling.
#
#    Additionally, the patch adds proper "basic" rate handling for STA
#    mode interface, AP mode interface will have to have new API added
#    to allow userspace to set the basic rate set, currently it'll be
#    empty... However, the basic rate handling will need to be moved to
#    the BSS conf stuff.
#
#    I do expect there to be bugs in this, especially wrt. transmit
#    power handling where I'm basically clueless about how it should work.
#
#    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
#    Signed-off-by: John W. Linville <linville@tuxdriver.com>

Changes-licensed-under: ISC
Signed-off-by: Stefan Lippers-Hollmann <s.l-h@gmx.de>
Signed-off-by: Antonio Galea <ant9000@netwise.it>

--- a/drivers/net/wireless/ar5523.c
+++ b/drivers/net/wireless/ar5523.c
@@ -129,7 +129,7 @@ struct ar5523 {
 
 	struct ieee80211_channel channels[14];
 	struct ieee80211_rate	 rates[12];
-	struct ieee80211_hw_mode modes[2];
+	struct ieee80211_supported_band band;
 	int			mode;
 
 };
@@ -416,12 +416,13 @@ static int ar5523_set_chan(struct ar5523
 
 	memset(&chan, 0, sizeof(chan));
 	chan.flags  = cpu_to_be32(0x1400);
-	chan.freq   = cpu_to_be32(conf->freq);
+	chan.freq   = cpu_to_be32(conf->channel->center_freq);
 	chan.magic1 = cpu_to_be32(20);
 	chan.magic2 = cpu_to_be32(50);
 	chan.magic3 = cpu_to_be32(1);
 
-	ar5523_dbg(ar, "switching to channel %d\n", conf->channel);
+	ar5523_dbg(ar, "switching to channel %d\n",
+		   ieee80211_frequency_to_channel(conf->channel->center_freq));
 
 	return ar5523_cmd_write(ar, AR5523_CMD_SET_CHAN,
 				&chan, sizeof(chan), 0);
@@ -574,9 +575,8 @@ static void ar5523_data_rx_cb(struct urb
 	 * need to poke into the descriptor if there might be more useful
 	 * information in there.
 	 */
-	rx_status.freq =  be32_to_cpu(desc->freq);
-	rx_status.channel = hw->conf.channel;
-	rx_status.phymode = hw->conf.phymode;
+	rx_status.freq = be32_to_cpu(desc->freq);
+	rx_status.band = hw->conf.channel->band;
 	rx_status.ssi = be32_to_cpu(desc->rssi);
 	
 	ieee80211_rx_irqsafe(hw, data->skb, &rx_status);
@@ -1281,15 +1281,16 @@ static int ar5523_reset(struct ar5523 *a
 static int ar5523_query_eeprom(struct ar5523 *ar)
 {
         int error;
+	u8 perm_addr[ETH_ALEN];
 	__be32 tmp;
 
 	/* retrieve MAC address */
-	error = ar5523_read_eeprom(ar, AR5523_EEPROM_MACADDR,
-				   &ar->hw->wiphy->perm_addr);
+	error = ar5523_read_eeprom(ar, AR5523_EEPROM_MACADDR, perm_addr);
 	if (error) {
 		ar5523_err(ar, "could not read MAC address\n");
 		return error;
 	}
+	SET_IEEE80211_PERM_ADDR(ar->hw, perm_addr);
 
 	/* retrieve the maximum frame size that the hardware can receive */
 	error = ar5523_read_eeprom(ar, AR5523_EEPROM_RXBUFSZ, &tmp);
@@ -1308,101 +1309,51 @@ static int ar5523_query_eeprom(struct ar
  * to common code as in OpenBSD.
  */
 static const struct ieee80211_rate ar5523_rates[] = {
-        { .rate = 10,
-	  .val = 0,
-	  .flags = IEEE80211_RATE_CCK },
-	{ .rate = 20,
-	  .val = 1,
-	  .flags = IEEE80211_RATE_CCK },
-	{ .rate = 55,
-	  .val = 2,
-	  .flags = IEEE80211_RATE_CCK },
-	{ .rate = 110,
-	  .val = 3,
-	  .flags = IEEE80211_RATE_CCK },
-	{ .rate = 60,
-	  .val = 4,
-	  .flags = IEEE80211_RATE_OFDM },
-	{ .rate = 90,
-	  .val = 5,
-	  .flags = IEEE80211_RATE_OFDM },
-	{ .rate = 120,
-	  .val = 6,
-	  .flags = IEEE80211_RATE_OFDM },
-	{ .rate = 180,
-	  .val = 7,
-	  .flags = IEEE80211_RATE_OFDM },
-	{ .rate = 240,
-	  .val = 8,
-	  .flags = IEEE80211_RATE_OFDM },
-	{ .rate = 360,
-	  .val = 9,
-	  .flags = IEEE80211_RATE_OFDM },
-	{ .rate = 480,
-	  .val = 10,
-	  .flags = IEEE80211_RATE_OFDM },
-	{ .rate = 540,
-	  .val = 11,
-	  .flags = IEEE80211_RATE_OFDM },
+	{ .bitrate = 10, .hw_value = 0, },
+	{ .bitrate = 20, .hw_value = 1, },
+	{ .bitrate = 55, .hw_value = 2, },
+	{ .bitrate = 110, .hw_value = 3, },
+	{ .bitrate = 60, .hw_value = 4, },
+	{ .bitrate = 90, .hw_value = 5, },
+	{ .bitrate = 120, .hw_value = 6, },
+	{ .bitrate = 180, .hw_value = 7, },
+	{ .bitrate = 240, .hw_value = 8, },
+	{ .bitrate = 360, .hw_value = 9, },
+	{ .bitrate = 480, .hw_value = 10, },
+	{ .bitrate = 540, .hw_value = 11, },
 };
 
 static const struct ieee80211_channel ar5523_channels[] = {
-        { .chan = 1,
-	  .freq = 2412},
-	{ .chan = 2,
-	  .freq = 2417},
-	{ .chan = 3,
-	  .freq = 2422},
-	{ .chan = 4,
-	  .freq = 2427},
-	{ .chan = 5,
-	  .freq = 2432},
-	{ .chan = 6,
-	  .freq = 2437},
-	{ .chan = 7,
-	  .freq = 2442},
-	{ .chan = 8,
-	  .freq = 2447},
-	{ .chan = 9,
-	  .freq = 2452},
-	{ .chan = 10,
-	  .freq = 2457},
-	{ .chan = 11,
-	  .freq = 2462},
-	{ .chan = 12,
-	  .freq = 2467},
-	{ .chan = 13,
-	  .freq = 2472},
-	{ .chan = 14,
-	  .freq = 2484},
+	{ .center_freq = 2412 },
+	{ .center_freq = 2417 },
+	{ .center_freq = 2422 },
+	{ .center_freq = 2427 },
+	{ .center_freq = 2432 },
+	{ .center_freq = 2437 },
+	{ .center_freq = 2442 },
+	{ .center_freq = 2447 },
+	{ .center_freq = 2452 },
+	{ .center_freq = 2457 },
+	{ .center_freq = 2462 },
+	{ .center_freq = 2467 },
+	{ .center_freq = 2472 },
+	{ .center_freq = 2484 },
 };
 
 static int ar5523_init_modes(struct ar5523 *ar)
 {
-	int error;
+	BUILD_BUG_ON(sizeof(ar->channels) != sizeof(ar5523_channels));
+	BUILD_BUG_ON(sizeof(ar->rates) != sizeof(ar5523_rates));
 
 	memcpy(ar->channels, ar5523_channels, sizeof(ar5523_channels));
 	memcpy(ar->rates, ar5523_rates, sizeof(ar5523_rates));
 
-	ar->modes[0].mode	= MODE_IEEE80211G;
-	ar->modes[0].num_rates	= ARRAY_SIZE(ar5523_rates);
-	ar->modes[0].rates	= ar->rates;
-	ar->modes[0].num_channels = ARRAY_SIZE(ar5523_channels);
-	ar->modes[0].channels	= ar->channels;
-
-	error = ieee80211_register_hwmode(ar->hw, &ar->modes[0]);
-	if (error)
-		return error;
-
-	ar->modes[1].mode	= MODE_IEEE80211B;
-	ar->modes[1].num_rates	= 4;
-	ar->modes[1].rates	= ar->rates;
-	ar->modes[1].num_channels = ARRAY_SIZE(ar5523_channels);
-	ar->modes[1].channels	= ar->channels;
-
-	error = ieee80211_register_hwmode(ar->hw, &ar->modes[1]);
-	if (error)
-		return error;
+	ar->band.band = IEEE80211_BAND_2GHZ;
+	ar->band.channels = ar->channels;
+	ar->band.n_channels = ARRAY_SIZE(ar5523_channels);
+	ar->band.bitrates = ar->rates;
+	ar->band.n_bitrates = ARRAY_SIZE(ar5523_rates);
+	ar->hw->wiphy->bands[IEEE80211_BAND_2GHZ] = &ar->band;
 
 	return 0;
 }
