From c9ef559aa6d503548eacf9231f6a0e560e0a7347 Mon Sep 17 00:00:00 2001
From: Pontus Fuchs <pontus.fuchs@gmail.com>
Date: Tue, 25 Sep 2012 20:02:30 +0200
Subject: [PATCH 47/68] RX path improvements

* Fix memory leaks on error paths
* Improve debug messages
---
 ar5523.c |   27 +++++++++++++--------------
 1 file changed, 13 insertions(+), 14 deletions(-)

--- a/drivers/net/wireless/ar5523.c
+++ b/drivers/net/wireless/ar5523.c
@@ -681,21 +681,14 @@ static void ar5523_data_rx_cb(struct urb
 
 	ar5523_dbg(ar, "%s\n", __func__);
 	/* sync/async unlink faults aren't errors */
-	if (urb->status && (urb->status != -ENOENT &&
-	    urb->status != -ECONNRESET && urb->status != -ESHUTDOWN)) {
-		ar5523_dbg(ar, "%s: nonzero write bulk status received: %d\n",
+	if (urb->status) {
+		ar5523_dbg(ar, "%s: USB err: %d\n",
 			   __func__, urb->status);
-
 		goto skip;
 	}
 
-	if (urb->status) {
-		/* do not try to resubmit urb */
-		return;
-	}
-
 	if (usblen < AR5523_MIN_RXBUFSZ) {
-		ar5523_err(ar, "wrong xfer size (usblen=%d)\n", usblen);
+		ar5523_err(ar, "RX: wrong xfer size (usblen=%d)\n", usblen);
 		goto skip;
 	}
 
@@ -707,7 +700,7 @@ static void ar5523_data_rx_cb(struct urb
 			   be16_to_cpu(chunk->length));
 
 	if ((chunk->flags & UATH_CFLAGS_FINAL) == 0) {
-		ar5523_err(ar, "No final in RX frame\n");
+		ar5523_err(ar, "RX: No final flag\n");
 		goto skip;
 	}
 
@@ -717,13 +710,15 @@ static void ar5523_data_rx_cb(struct urb
 
 	rxlen = be32_to_cpu(desc->len);
 	if (rxlen > ar->rxbufsz) {
-		ar5523_dbg(ar, "bad descriptor (len=%d)\n",
+		ar5523_dbg(ar, "RX: Bad descriptor (len=%d)\n",
 			   be32_to_cpu(desc->len));
 		goto skip;
 	}
 
-	if (!rxlen)
+	if (!rxlen) {
+		ar5523_dbg(ar, "RX: rxlen is 0\n");
 		goto skip;
+	}
 
 	if (be32_to_cpu(desc->status) != 0) {
 		ar5523_dbg(ar, "Bad RX status (0x%x). Skip\n",
@@ -750,9 +745,13 @@ static void ar5523_data_rx_cb(struct urb
 	rx_status->signal = -95 + be32_to_cpu(desc->rssi);
 
 	ieee80211_rx_irqsafe(hw, data->skb);
+	data->skb = NULL;
 
 skip:
-	data->skb = NULL;
+	if (data->skb) {
+		dev_kfree_skb_irq(data->skb);
+		data->skb = NULL;
+	}
 	spin_lock_irqsave(&ar->rx_data_list_lock, flags);
 	list_move(&data->list, &ar->rx_data_free);
 	spin_unlock_irqrestore(&ar->rx_data_list_lock, flags);
