--- a/drivers/net/wireless/ath/ath9k/hw.h
+++ b/drivers/net/wireless/ath/ath9k/hw.h
@@ -716,6 +716,7 @@ struct ath_spec_scan {
  * @config_pci_powersave:
  * @calibrate: periodic calibration for NF, ANI, IQ, ADC gain, ADC-DC
  *
+ * @get_adc_entropy: get entropy from the raw ADC I/Q output
  * @spectral_scan_config: set parameters for spectral scan and enable/disable it
  * @spectral_scan_trigger: trigger a spectral scan run
  * @spectral_scan_wait: wait for a spectral scan run to finish
@@ -750,6 +751,10 @@ struct ath_hw_ops {
 #ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
 	void (*set_bt_ant_diversity)(struct ath_hw *hw, bool enable);
 #endif
+
+#ifdef CONFIG_ATH9K_HWRNG
+	int (*get_adc_entropy)(struct ath_hw *ah, u32 *buf, const u32 buf_size, u32 *rng_last);
+#endif
 };
 
 struct ath_nf_limits {
--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
@@ -1927,6 +1927,33 @@ void ar9003_hw_init_rate_txpower(struct
 	}
 }
 
+static int __maybe_unused
+ar9003_hw_get_adc_entropy(struct ath_hw *ah, u32 *buf, const u32 buf_size, u32 *rng_last)
+{
+	int i, j;
+	u32  v1, v2, last = *rng_last;
+
+	REG_RMW_FIELD(ah, AR_PHY_TEST, AR_PHY_TEST_BBB_OBS_SEL, 1);
+	REG_CLR_BIT(ah, AR_PHY_TEST, AR_PHY_TEST_RX_OBS_SEL_BIT5);
+	REG_RMW_FIELD(ah, AR_PHY_TEST_CTL_STATUS, AR_PHY_TEST_CTL_RX_OBS_SEL, 0);
+
+	for (i = 0, j = 0; i < buf_size; i++) {
+		v1 = REG_READ(ah, AR_PHY_TST_ADC) & 0xffff;
+		v2 = REG_READ(ah, AR_PHY_TST_ADC) & 0xffff;
+
+		/* wait for data ready */
+		if (v1 && v2 && last != v1 && v1 != v2 && v1 != 0xffff &&
+		    v2 != 0xffff)
+			buf[j++] = (v1 << 16) | v2;
+
+		last = v2;
+	}
+
+	*rng_last = last;
+
+	return j << 2;
+}
+
 void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
 {
 	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
@@ -1963,6 +1990,9 @@ void ar9003_hw_attach_phy_ops(struct ath
 	priv_ops->set_radar_params = ar9003_hw_set_radar_params;
 	priv_ops->fast_chan_change = ar9003_hw_fast_chan_change;
 
+#ifdef CONFIG_ATH9K_HWRNG
+	ops->get_adc_entropy = ar9003_hw_get_adc_entropy;
+#endif
 	ops->antdiv_comb_conf_get = ar9003_hw_antdiv_comb_conf_get;
 	ops->antdiv_comb_conf_set = ar9003_hw_antdiv_comb_conf_set;
 	ops->spectral_scan_config = ar9003_hw_spectral_scan_config;
--- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
@@ -1340,9 +1340,38 @@ void ar5008_hw_init_rate_txpower(struct
 	}
 }
 
+static int __maybe_unused
+ar5008_hw_get_adc_entropy(struct ath_hw *ah, u32 *buf, const u32 buf_size, u32 *rng_last)
+{
+	int i, j;
+	u32 v1, v2, last = *rng_last;
+
+	REG_RMW_FIELD(ah, AR_PHY_TEST, AR_PHY_TEST_BBB_OBS_SEL, 1);
+	REG_CLR_BIT(ah, AR_PHY_TEST, AR_PHY_TEST_RX_OBS_SEL_BIT5);
+	REG_RMW_FIELD(ah, AR_PHY_TEST2, AR_PHY_TEST2_RX_OBS_SEL, 0);
+
+	for (i = 0, j = 0; i < buf_size; i++) {
+		v1 = REG_READ(ah, AR_PHY_TST_ADC) & 0xffff;
+		v2 = REG_READ(ah, AR_PHY_TST_ADC) & 0xffff;
+
+		/* wait for data ready */
+		if (v1 && v2 && last != v1 && v1 != v2 && v1 != 0xffff &&
+		    v2 != 0xffff)
+			buf[j++] = (v1 << 16) | v2;
+
+		last = v2;
+	}
+
+	*rng_last = last;
+
+	return j << 2;
+}
+
 int ar5008_hw_attach_phy_ops(struct ath_hw *ah)
 {
 	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
+	struct ath_hw_ops *ops __maybe_unused;
+
 	static const u32 ar5416_cca_regs[6] = {
 		AR_PHY_CCA,
 		AR_PHY_CH1_CCA,
@@ -1357,6 +1386,11 @@ int ar5008_hw_attach_phy_ops(struct ath_
 	if (ret)
 	    return ret;
 
+#ifdef CONFIG_ATH9K_HWRNG
+	ops = ath9k_hw_ops(ah);
+	ops->get_adc_entropy = ar5008_hw_get_adc_entropy;
+#endif
+
 	priv_ops->rf_set_freq = ar5008_hw_set_channel;
 	priv_ops->spur_mitigate_freq = ar5008_hw_spur_mitigate;
 
--- a/drivers/net/wireless/ath/ath9k/ar9002_phy.h
+++ b/drivers/net/wireless/ath/ath9k/ar9002_phy.h
@@ -20,6 +20,12 @@
 #define PHY_AGC_CLR             0x10000000
 #define RFSILENT_BB             0x00002000
 
+#define AR_PHY_TEST_BBB_OBS_SEL       0x780000
+#define AR_PHY_TEST_BBB_OBS_SEL_S     19
+
+#define AR_PHY_TEST_RX_OBS_SEL_BIT5_S 23
+#define AR_PHY_TEST_RX_OBS_SEL_BIT5   (1 << AR_PHY_TEST_RX_OBS_SEL_BIT5_S)
+
 #define AR_PHY_TURBO                0x9804
 #define AR_PHY_FC_TURBO_MODE        0x00000001
 #define AR_PHY_FC_TURBO_SHORT       0x00000002
@@ -36,6 +42,9 @@
 
 #define AR_PHY_TEST2			0x9808
 
+#define AR_PHY_TEST2_RX_OBS_SEL        0x3C00
+#define AR_PHY_TEST2_RX_OBS_SEL_S      10
+
 #define AR_PHY_TIMING2           0x9810
 #define AR_PHY_TIMING3           0x9814
 #define AR_PHY_TIMING3_DSC_MAN   0xFFFE0000
@@ -393,6 +402,8 @@
 #define AR_PHY_RFBUS_GRANT       0x9C20
 #define AR_PHY_RFBUS_GRANT_EN    0x00000001
 
+#define AR_PHY_TST_ADC      0x9C24
+
 #define AR_PHY_CHAN_INFO_GAIN_DIFF             0x9CF4
 #define AR_PHY_CHAN_INFO_GAIN_DIFF_UPPER_LIMIT 320
 
--- a/drivers/net/wireless/ath/ath9k/rng.c
+++ b/drivers/net/wireless/ath/ath9k/rng.c
@@ -19,42 +19,30 @@
 
 #include "ath9k.h"
 #include "hw.h"
-#include "ar9003_phy.h"
 
 #define ATH9K_RNG_BUF_SIZE	320
 #define ATH9K_RNG_ENTROPY(x)	(((x) * 8 * 10) >> 5) /* quality: 10/32 */
 
 static DECLARE_WAIT_QUEUE_HEAD(rng_queue);
 
-static int ath9k_rng_data_read(struct ath_softc *sc, u32 *buf, u32 buf_size)
+static inline int ath9k_hw_get_adc_entropy(struct ath_hw *ah,
+	u32 *buf, const u32 buf_size, u32 *rng_last)
+{
+	return ath9k_hw_ops(ah)->get_adc_entropy(ah, buf, buf_size, rng_last);
+}
+
+static int ath9k_rng_data_read(struct ath_softc *sc, u32 *buf, const u32 buf_size)
 {
-	int i, j;
-	u32  v1, v2, rng_last = sc->rng_last;
 	struct ath_hw *ah = sc->sc_ah;
+	int bytes_read;
 
 	ath9k_ps_wakeup(sc);
 
-	REG_RMW_FIELD(ah, AR_PHY_TEST, AR_PHY_TEST_BBB_OBS_SEL, 1);
-	REG_CLR_BIT(ah, AR_PHY_TEST, AR_PHY_TEST_RX_OBS_SEL_BIT5);
-	REG_RMW_FIELD(ah, AR_PHY_TEST_CTL_STATUS, AR_PHY_TEST_CTL_RX_OBS_SEL, 0);
-
-	for (i = 0, j = 0; i < buf_size; i++) {
-		v1 = REG_READ(ah, AR_PHY_TST_ADC) & 0xffff;
-		v2 = REG_READ(ah, AR_PHY_TST_ADC) & 0xffff;
-
-		/* wait for data ready */
-		if (v1 && v2 && rng_last != v1 && v1 != v2 && v1 != 0xffff &&
-		    v2 != 0xffff)
-			buf[j++] = (v1 << 16) | v2;
-
-		rng_last = v2;
-	}
+	bytes_read = ath9k_hw_get_adc_entropy(ah, buf, buf_size, &sc->rng_last);
 
 	ath9k_ps_restore(sc);
 
-	sc->rng_last = rng_last;
-
-	return j << 2;
+	return bytes_read;
 }
 
 static u32 ath9k_rng_delay_get(u32 fail_stats)
@@ -109,14 +97,9 @@ out:
 
 void ath9k_rng_start(struct ath_softc *sc)
 {
-	struct ath_hw *ah = sc->sc_ah;
-
 	if (sc->rng_task)
 		return;
 
-	if (!AR_SREV_9300_20_OR_LATER(ah))
-		return;
-
 	sc->rng_task = kthread_run(ath9k_rng_kthread, sc, "ath9k-hwrng");
 	if (IS_ERR(sc->rng_task))
 		sc->rng_task = NULL;
