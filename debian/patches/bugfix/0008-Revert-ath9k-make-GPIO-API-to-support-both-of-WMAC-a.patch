From 8f2b20cb0506469c7ef3ce1cd1a50e7cd5d849ee Mon Sep 17 00:00:00 2001
From: Stefan Lippers-Hollmann <s.l-h@gmx.de>
Date: Sun, 17 Jul 2016 21:37:39 +0200
Subject: [PATCH 8/9] Revert "ath9k: make GPIO API to support both of WMAC and
 SOC"

This reverts commit b2d70d4944c1789bc64376ad97a811f37e230c87.
---
 drivers/net/wireless/ath/ath9k/ar9003_eeprom.c |   4 +-
 drivers/net/wireless/ath/ath9k/ar9003_mci.c    |  39 ++---
 drivers/net/wireless/ath/ath9k/btcoex.c        |  27 ++--
 drivers/net/wireless/ath/ath9k/gpio.c          |   6 +-
 drivers/net/wireless/ath/ath9k/htc_drv_gpio.c  |   6 +-
 drivers/net/wireless/ath/ath9k/hw.c            | 196 ++++++++++---------------
 drivers/net/wireless/ath/ath9k/hw.h            |  10 +-
 drivers/net/wireless/ath/ath9k/main.c          |   6 +-
 8 files changed, 120 insertions(+), 174 deletions(-)

--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
@@ -3590,8 +3590,8 @@ static void ar9003_hw_ant_ctrl_apply(str
 		else
 			gpio = AR9300_EXT_LNA_CTL_GPIO_AR9485;
 
-		ath9k_hw_gpio_request_out(ah, gpio, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_PCIE_ATTENTION_LED);
+		ath9k_hw_cfg_output(ah, gpio,
+				    AR_GPIO_OUTPUT_MUX_AS_PCIE_ATTENTION_LED);
 	}
 
 	value = ar9003_hw_ant_ctrl_common_get(ah, is2ghz);
--- a/drivers/net/wireless/ath/ath9k/ar9003_mci.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_mci.c
@@ -427,34 +427,21 @@ static void ar9003_mci_observation_set_u
 	struct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;
 
 	if (mci->config & ATH_MCI_CONFIG_MCI_OBS_MCI) {
-		ath9k_hw_gpio_request_out(ah, 3, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_MCI_WLAN_DATA);
-		ath9k_hw_gpio_request_out(ah, 2, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_MCI_WLAN_CLK);
-		ath9k_hw_gpio_request_out(ah, 1, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA);
-		ath9k_hw_gpio_request_out(ah, 0, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK);
+		ath9k_hw_cfg_output(ah, 3, AR_GPIO_OUTPUT_MUX_AS_MCI_WLAN_DATA);
+		ath9k_hw_cfg_output(ah, 2, AR_GPIO_OUTPUT_MUX_AS_MCI_WLAN_CLK);
+		ath9k_hw_cfg_output(ah, 1, AR_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA);
+		ath9k_hw_cfg_output(ah, 0, AR_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK);
 	} else if (mci->config & ATH_MCI_CONFIG_MCI_OBS_TXRX) {
-		ath9k_hw_gpio_request_out(ah, 3, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_WL_IN_TX);
-		ath9k_hw_gpio_request_out(ah, 2, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_WL_IN_RX);
-		ath9k_hw_gpio_request_out(ah, 1, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_BT_IN_TX);
-		ath9k_hw_gpio_request_out(ah, 0, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_BT_IN_RX);
-		ath9k_hw_gpio_request_out(ah, 5, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+		ath9k_hw_cfg_output(ah, 3, AR_GPIO_OUTPUT_MUX_AS_WL_IN_TX);
+		ath9k_hw_cfg_output(ah, 2, AR_GPIO_OUTPUT_MUX_AS_WL_IN_RX);
+		ath9k_hw_cfg_output(ah, 1, AR_GPIO_OUTPUT_MUX_AS_BT_IN_TX);
+		ath9k_hw_cfg_output(ah, 0, AR_GPIO_OUTPUT_MUX_AS_BT_IN_RX);
+		ath9k_hw_cfg_output(ah, 5, AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
 	} else if (mci->config & ATH_MCI_CONFIG_MCI_OBS_BT) {
-		ath9k_hw_gpio_request_out(ah, 3, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_BT_IN_TX);
-		ath9k_hw_gpio_request_out(ah, 2, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_BT_IN_RX);
-		ath9k_hw_gpio_request_out(ah, 1, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA);
-		ath9k_hw_gpio_request_out(ah, 0, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK);
+		ath9k_hw_cfg_output(ah, 3, AR_GPIO_OUTPUT_MUX_AS_BT_IN_TX);
+		ath9k_hw_cfg_output(ah, 2, AR_GPIO_OUTPUT_MUX_AS_BT_IN_RX);
+		ath9k_hw_cfg_output(ah, 1, AR_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA);
+		ath9k_hw_cfg_output(ah, 0, AR_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK);
 	} else
 		return;
 
--- a/drivers/net/wireless/ath/ath9k/btcoex.c
+++ b/drivers/net/wireless/ath/ath9k/btcoex.c
@@ -142,8 +142,7 @@ void ath9k_hw_btcoex_init_2wire(struct a
 		      btcoex_hw->btactive_gpio);
 
 	/* Configure the desired gpio port for input */
-	ath9k_hw_gpio_request_in(ah, btcoex_hw->btactive_gpio,
-				 "ath9k-btactive");
+	ath9k_hw_cfg_gpio_input(ah, btcoex_hw->btactive_gpio);
 }
 EXPORT_SYMBOL(ath9k_hw_btcoex_init_2wire);
 
@@ -167,10 +166,9 @@ void ath9k_hw_btcoex_init_3wire(struct a
 			btcoex_hw->btpriority_gpio);
 
 	/* Configure the desired GPIO ports for input */
-	ath9k_hw_gpio_request_in(ah, btcoex_hw->btactive_gpio,
-				 "ath9k-btactive");
-	ath9k_hw_gpio_request_in(ah, btcoex_hw->btpriority_gpio,
-				 "ath9k-btpriority");
+
+	ath9k_hw_cfg_gpio_input(ah, btcoex_hw->btactive_gpio);
+	ath9k_hw_cfg_gpio_input(ah, btcoex_hw->btpriority_gpio);
 }
 EXPORT_SYMBOL(ath9k_hw_btcoex_init_3wire);
 
@@ -203,9 +201,8 @@ static void ath9k_hw_btcoex_enable_2wire
 	struct ath_btcoex_hw *btcoex_hw = &ah->btcoex_hw;
 
 	/* Configure the desired GPIO port for TX_FRAME output */
-	ath9k_hw_gpio_request_out(ah, btcoex_hw->wlanactive_gpio,
-				  "ath9k-wlanactive",
-				  AR_GPIO_OUTPUT_MUX_AS_TX_FRAME);
+	ath9k_hw_cfg_output(ah, btcoex_hw->wlanactive_gpio,
+			    AR_GPIO_OUTPUT_MUX_AS_TX_FRAME);
 }
 
 /*
@@ -274,6 +271,7 @@ static void ath9k_hw_btcoex_enable_3wire
 	REG_WRITE(ah, AR_BT_COEX_MODE, btcoex->bt_coex_mode);
 	REG_WRITE(ah, AR_BT_COEX_MODE2, btcoex->bt_coex_mode2);
 
+
 	if (AR_SREV_9300_20_OR_LATER(ah)) {
 		REG_WRITE(ah, AR_BT_COEX_WL_WEIGHTS0, btcoex->wlan_weight[0]);
 		REG_WRITE(ah, AR_BT_COEX_WL_WEIGHTS1, btcoex->wlan_weight[1]);
@@ -283,6 +281,8 @@ static void ath9k_hw_btcoex_enable_3wire
 	} else
 		REG_WRITE(ah, AR_BT_COEX_WEIGHT, btcoex->bt_coex_weights);
 
+
+
 	if (AR_SREV_9271(ah)) {
 		val = REG_READ(ah, 0x50040);
 		val &= 0xFFFFFEFF;
@@ -292,9 +292,8 @@ static void ath9k_hw_btcoex_enable_3wire
 	REG_RMW_FIELD(ah, AR_QUIET1, AR_QUIET1_QUIET_ACK_CTS_ENABLE, 1);
 	REG_RMW_FIELD(ah, AR_PCU_MISC, AR_PCU_BT_ANT_PREVENT_RX, 0);
 
-	ath9k_hw_gpio_request_out(ah, btcoex->wlanactive_gpio,
-				  "ath9k-wlanactive",
-				  AR_GPIO_OUTPUT_MUX_AS_RX_CLEAR_EXTERNAL);
+	ath9k_hw_cfg_output(ah, btcoex->wlanactive_gpio,
+			    AR_GPIO_OUTPUT_MUX_AS_RX_CLEAR_EXTERNAL);
 }
 
 static void ath9k_hw_btcoex_enable_mci(struct ath_hw *ah)
@@ -365,8 +364,8 @@ void ath9k_hw_btcoex_disable(struct ath_
 	if (!AR_SREV_9300_20_OR_LATER(ah))
 		ath9k_hw_set_gpio(ah, btcoex_hw->wlanactive_gpio, 0);
 
-	ath9k_hw_gpio_request_out(ah, btcoex_hw->wlanactive_gpio,
-				  NULL, AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+	ath9k_hw_cfg_output(ah, btcoex_hw->wlanactive_gpio,
+			AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
 
 	if (btcoex_hw->scheme == ATH_BTCOEX_CFG_3WIRE) {
 		REG_WRITE(ah, AR_BT_COEX_MODE, AR_BT_QUIET | AR_BT_MODE);
--- a/drivers/net/wireless/ath/ath9k/gpio.c
+++ b/drivers/net/wireless/ath/ath9k/gpio.c
@@ -74,8 +74,7 @@ void ath_fill_led_pin(struct ath_softc *
 
 	if (ah->led_pin >= 0) {
 		if (!((1 << ah->led_pin) & AR_GPIO_OE_OUT_MASK))
-			ath9k_hw_gpio_request_out(ah, ah->led_pin, "ath9k-led",
-						  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+			ath9k_hw_request_gpio(ah, ah->led_pin, "ath9k-led");
 		return;
 	}
 
@@ -91,8 +90,7 @@ void ath_fill_led_pin(struct ath_softc *
 		ah->led_pin = ATH_LED_PIN_DEF;
 
 	/* Configure gpio 1 for output */
-	ath9k_hw_gpio_request_out(ah, ah->led_pin, "ath9k-led",
-				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+	ath9k_hw_cfg_output(ah, ah->led_pin, AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
 
 	/* LED off, active low */
 	ath9k_hw_set_gpio(ah, ah->led_pin, (ah->config.led_active_high) ? 0 : 1);
--- a/drivers/net/wireless/ath/ath9k/htc_drv_gpio.c
+++ b/drivers/net/wireless/ath/ath9k/htc_drv_gpio.c
@@ -259,11 +259,11 @@ void ath9k_deinit_leds(struct ath9k_htc_
 void ath9k_configure_leds(struct ath9k_htc_priv *priv)
 {
 	/* Configure gpio 1 for output */
-	ath9k_hw_gpio_request_out(priv->ah, priv->ah->led_pin,
-				  "ath9k-led",
-				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+	ath9k_hw_cfg_output(priv->ah, priv->ah->led_pin,
+			    AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
 	/* LED off, active low */
 	ath9k_hw_set_gpio(priv->ah, priv->ah->led_pin, 1);
+
 }
 
 void ath9k_init_leds(struct ath9k_htc_priv *priv)
--- a/drivers/net/wireless/ath/ath9k/hw.c
+++ b/drivers/net/wireless/ath/ath9k/hw.c
@@ -1582,8 +1582,7 @@ static void ath9k_hw_apply_gpio_override
 		if (!(gpio_mask & 1))
 			continue;
 
-		ath9k_hw_gpio_request_out(ah, i, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+		ath9k_hw_cfg_output(ah, i, AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
 		ath9k_hw_set_gpio(ah, i, !!(ah->gpio_val & BIT(i)));
 	}
 }
@@ -1959,7 +1958,7 @@ int ath9k_hw_reset(struct ath_hw *ah, st
 	ath9k_hw_init_qos(ah);
 
 	if (ah->caps.hw_caps & ATH9K_HW_CAP_RFSILENT)
-		ath9k_hw_gpio_request_in(ah, ah->rfkill_gpio, "ath9k-rfkill");
+		ath9k_hw_cfg_gpio_input(ah, ah->rfkill_gpio);
 
 	ath9k_hw_init_global_settings(ah);
 
@@ -2655,7 +2654,8 @@ int ath9k_hw_fill_cap_info(struct ath_hw
 /* GPIO / RFKILL / Antennae */
 /****************************/
 
-static void ath9k_hw_gpio_cfg_output_mux(struct ath_hw *ah, u32 gpio, u32 type)
+static void ath9k_hw_gpio_cfg_output_mux(struct ath_hw *ah,
+					 u32 gpio, u32 type)
 {
 	int addr;
 	u32 gpio_shift, tmp;
@@ -2669,8 +2669,8 @@ static void ath9k_hw_gpio_cfg_output_mux
 
 	gpio_shift = (gpio % 6) * 5;
 
-	if (AR_SREV_9280_20_OR_LATER(ah) ||
-	    (addr != AR_GPIO_OUTPUT_MUX1)) {
+	if (AR_SREV_9280_20_OR_LATER(ah)
+	    || (addr != AR_GPIO_OUTPUT_MUX1)) {
 		REG_RMW(ah, addr, (type << gpio_shift),
 			(0x1f << gpio_shift));
 	} else {
@@ -2682,144 +2682,106 @@ static void ath9k_hw_gpio_cfg_output_mux
 	}
 }
 
-/* BSP should set the corresponding MUX register correctly.
- */
-static void ath9k_hw_gpio_cfg_soc(struct ath_hw *ah, u32 gpio, bool out,
-				  const char *label)
+void ath9k_hw_cfg_gpio_input(struct ath_hw *ah, u32 gpio)
 {
-	if (ah->caps.gpio_requested & BIT(gpio))
-		return;
+	u32 gpio_shift;
 
-	/* may be requested by BSP, free anyway */
-	gpio_free(gpio);
+	BUG_ON(gpio >= ah->caps.num_gpio_pins);
 
-	if (gpio_request_one(gpio, out ? GPIOF_OUT_INIT_LOW : GPIOF_IN, label))
+	if (AR_DEVID_7010(ah)) {
+		gpio_shift = gpio;
+		REG_RMW(ah, AR7010_GPIO_OE,
+			(AR7010_GPIO_OE_AS_INPUT << gpio_shift),
+			(AR7010_GPIO_OE_MASK << gpio_shift));
 		return;
+	}
 
-	ah->caps.gpio_requested |= BIT(gpio);
+	gpio_shift = gpio << 1;
+	REG_RMW(ah,
+		AR_GPIO_OE_OUT,
+		(AR_GPIO_OE_OUT_DRV_NO << gpio_shift),
+		(AR_GPIO_OE_OUT_DRV << gpio_shift));
 }
+EXPORT_SYMBOL(ath9k_hw_cfg_gpio_input);
 
-static void ath9k_hw_gpio_cfg_wmac(struct ath_hw *ah, u32 gpio, bool out,
-				   u32 ah_signal_type)
+u32 ath9k_hw_gpio_get(struct ath_hw *ah, u32 gpio)
 {
-	u32 gpio_set, gpio_shift = gpio;
-
-	if (AR_DEVID_7010(ah)) {
-		gpio_set = out ?
-			AR7010_GPIO_OE_AS_OUTPUT : AR7010_GPIO_OE_AS_INPUT;
-		REG_RMW(ah, AR7010_GPIO_OE, gpio_set << gpio_shift,
-			AR7010_GPIO_OE_MASK << gpio_shift);
-	} else if (AR_SREV_SOC(ah)) {
-		gpio_set = out ? 1 : 0;
-		REG_RMW(ah, AR_GPIO_OE_OUT, gpio_set << gpio_shift,
-			gpio_set << gpio_shift);
-	} else {
-		gpio_shift = gpio << 1;
-		gpio_set = out ?
-			AR_GPIO_OE_OUT_DRV_ALL : AR_GPIO_OE_OUT_DRV_NO;
-		REG_RMW(ah, AR_GPIO_OE_OUT, gpio_set << gpio_shift,
-			AR_GPIO_OE_OUT_DRV << gpio_shift);
+#define MS_REG_READ(x, y) \
+	(MS(REG_READ(ah, AR_GPIO_IN_OUT), x##_GPIO_IN_VAL) & (AR_GPIO_BIT(y)))
 
-		if (out)
-			ath9k_hw_gpio_cfg_output_mux(ah, gpio, ah_signal_type);
-	}
-}
+	if (gpio >= ah->caps.num_gpio_pins)
+		return 0xffffffff;
 
-static void ath9k_hw_gpio_request(struct ath_hw *ah, u32 gpio, bool out,
-				  const char *label, u32 ah_signal_type)
-{
-	WARN_ON(gpio >= ah->caps.num_gpio_pins);
-
-	if (BIT(gpio) & ah->caps.gpio_mask)
-		ath9k_hw_gpio_cfg_wmac(ah, gpio, out, ah_signal_type);
-	else if (AR_SREV_SOC(ah))
-		ath9k_hw_gpio_cfg_soc(ah, gpio, out, label);
+	if (AR_DEVID_7010(ah)) {
+		u32 val;
+		val = REG_READ(ah, AR7010_GPIO_IN);
+		return (MS(val, AR7010_GPIO_IN_VAL) & AR_GPIO_BIT(gpio)) == 0;
+	} else if (AR_SREV_9300_20_OR_LATER(ah))
+		return (MS(REG_READ(ah, AR_GPIO_IN), AR9300_GPIO_IN_VAL) &
+			AR_GPIO_BIT(gpio)) != 0;
+	else if (AR_SREV_9271(ah))
+		return MS_REG_READ(AR9271, gpio) != 0;
+	else if (AR_SREV_9287_11_OR_LATER(ah))
+		return MS_REG_READ(AR9287, gpio) != 0;
+	else if (AR_SREV_9285_12_OR_LATER(ah))
+		return MS_REG_READ(AR9285, gpio) != 0;
+	else if (AR_SREV_9280_20_OR_LATER(ah))
+		return MS_REG_READ(AR928X, gpio) != 0;
 	else
-		WARN_ON(1);
+		return MS_REG_READ(AR, gpio) != 0;
 }
+EXPORT_SYMBOL(ath9k_hw_gpio_get);
 
-void ath9k_hw_gpio_request_in(struct ath_hw *ah, u32 gpio, const char *label)
+void ath9k_hw_cfg_output(struct ath_hw *ah, u32 gpio,
+			 u32 ah_signal_type)
 {
-	ath9k_hw_gpio_request(ah, gpio, false, label, 0);
-}
-EXPORT_SYMBOL(ath9k_hw_gpio_request_in);
+	u32 gpio_shift;
 
-void ath9k_hw_gpio_request_out(struct ath_hw *ah, u32 gpio, const char *label,
-			       u32 ah_signal_type)
-{
-	ath9k_hw_gpio_request(ah, gpio, true, label, ah_signal_type);
-}
-EXPORT_SYMBOL(ath9k_hw_gpio_request_out);
-
-void ath9k_hw_gpio_free(struct ath_hw *ah, u32 gpio)
-{
-	if (!AR_SREV_SOC(ah))
+	if (AR_DEVID_7010(ah)) {
+		gpio_shift = gpio;
+		REG_RMW(ah, AR7010_GPIO_OE,
+			(AR7010_GPIO_OE_AS_OUTPUT << gpio_shift),
+			(AR7010_GPIO_OE_MASK << gpio_shift));
 		return;
-
-	WARN_ON(gpio >= ah->caps.num_gpio_pins);
-
-	if (ah->caps.gpio_requested & BIT(gpio)) {
-		gpio_free(gpio);
-		ah->caps.gpio_requested &= ~BIT(gpio);
 	}
+
+	ath9k_hw_gpio_cfg_output_mux(ah, gpio, ah_signal_type);
+	gpio_shift = 2 * gpio;
+	REG_RMW(ah,
+		AR_GPIO_OE_OUT,
+		(AR_GPIO_OE_OUT_DRV_ALL << gpio_shift),
+		(AR_GPIO_OE_OUT_DRV << gpio_shift));
 }
-EXPORT_SYMBOL(ath9k_hw_gpio_free);
+EXPORT_SYMBOL(ath9k_hw_cfg_output);
 
-u32 ath9k_hw_gpio_get(struct ath_hw *ah, u32 gpio)
+void ath9k_hw_set_gpio(struct ath_hw *ah, u32 gpio, u32 val)
 {
-	u32 val = 0xffffffff;
-
-#define MS_REG_READ(x, y) \
-	(MS(REG_READ(ah, AR_GPIO_IN_OUT), x##_GPIO_IN_VAL) & BIT(y))
-
-	WARN_ON(gpio >= ah->caps.num_gpio_pins);
-
-	if (BIT(gpio) & ah->caps.gpio_mask) {
-		if (AR_SREV_9271(ah))
-			val = MS_REG_READ(AR9271, gpio);
-		else if (AR_SREV_9287(ah))
-			val = MS_REG_READ(AR9287, gpio);
-		else if (AR_SREV_9285(ah))
-			val = MS_REG_READ(AR9285, gpio);
-		else if (AR_SREV_9280(ah))
-			val = MS_REG_READ(AR928X, gpio);
-		else if (AR_DEVID_7010(ah))
-			val = REG_READ(ah, AR7010_GPIO_IN) & BIT(gpio);
-		else if (AR_SREV_9300_20_OR_LATER(ah))
-			val = REG_READ(ah, AR_GPIO_IN) & BIT(gpio);
-		else
-			val = MS_REG_READ(AR, gpio);
-	} else if (BIT(gpio) & ah->caps.gpio_requested) {
-		val = gpio_get_value(gpio) & BIT(gpio);
-	} else {
-		WARN_ON(1);
+	if (AR_DEVID_7010(ah)) {
+		val = val ? 0 : 1;
+		REG_RMW(ah, AR7010_GPIO_OUT, ((val&1) << gpio),
+			AR_GPIO_BIT(gpio));
+		return;
 	}
 
-	return val;
+	if (AR_SREV_9271(ah))
+		val = ~val;
+
+	if ((1 << gpio) & AR_GPIO_OE_OUT_MASK)
+		REG_RMW(ah, AR_GPIO_IN_OUT, ((val & 1) << gpio),
+			AR_GPIO_BIT(gpio));
+	else
+		gpio_set_value(gpio, val & 1);
 }
-EXPORT_SYMBOL(ath9k_hw_gpio_get);
+EXPORT_SYMBOL(ath9k_hw_set_gpio);
 
-void ath9k_hw_set_gpio(struct ath_hw *ah, u32 gpio, u32 val)
+void ath9k_hw_request_gpio(struct ath_hw *ah, u32 gpio, const char *label)
 {
-	WARN_ON(gpio >= ah->caps.num_gpio_pins);
-
-	if (AR_DEVID_7010(ah) || AR_SREV_9271(ah))
-		val = !val;
-	else
-		val = !!val;
+	if (gpio >= ah->caps.num_gpio_pins)
+		return;
 
-	if (BIT(gpio) & ah->caps.gpio_mask) {
-		u32 out_addr = AR_DEVID_7010(ah) ?
-			AR7010_GPIO_OUT : AR_GPIO_IN_OUT;
-
-		REG_RMW(ah, out_addr, val << gpio, BIT(gpio));
-	} else if (BIT(gpio) & ah->caps.gpio_requested) {
-		gpio_set_value(gpio, val);
-	} else {
-		WARN_ON(1);
-	}
+	gpio_request_one(gpio, GPIOF_DIR_OUT | GPIOF_INIT_LOW, label);
 }
-EXPORT_SYMBOL(ath9k_hw_set_gpio);
+EXPORT_SYMBOL(ath9k_hw_request_gpio);
 
 void ath9k_hw_setantenna(struct ath_hw *ah, u32 antenna)
 {
--- a/drivers/net/wireless/ath/ath9k/hw.h
+++ b/drivers/net/wireless/ath/ath9k/hw.h
@@ -160,6 +160,7 @@
 #define AR_GPIO_OUTPUT_MUX_AS_RUCKUS_DATA        0x1e
 
 #define AR_GPIOD_MASK               0x00001FFF
+#define AR_GPIO_BIT(_gpio)          (1 << (_gpio))
 
 #define BASE_ACTIVATE_DELAY         100
 #define RTC_PLL_SETTLE_DELAY        (AR_SREV_9340(ah) ? 1000 : 100)
@@ -301,7 +302,6 @@ struct ath9k_hw_capabilities {
 	u8 max_rxchains;
 	u8 num_gpio_pins;
 	u32 gpio_mask;
-	u32 gpio_requested;
 	u8 rx_hp_qdepth;
 	u8 rx_lp_qdepth;
 	u8 rx_status_len;
@@ -1020,12 +1020,12 @@ int ath9k_hw_fill_cap_info(struct ath_hw
 u32 ath9k_regd_get_ctl(struct ath_regulatory *reg, struct ath9k_channel *chan);
 
 /* GPIO / RFKILL / Antennae */
-void ath9k_hw_gpio_request_in(struct ath_hw *ah, u32 gpio, const char *label);
-void ath9k_hw_gpio_request_out(struct ath_hw *ah, u32 gpio, const char *label,
-			       u32 ah_signal_type);
-void ath9k_hw_gpio_free(struct ath_hw *ah, u32 gpio);
+void ath9k_hw_cfg_gpio_input(struct ath_hw *ah, u32 gpio);
 u32 ath9k_hw_gpio_get(struct ath_hw *ah, u32 gpio);
+void ath9k_hw_cfg_output(struct ath_hw *ah, u32 gpio,
+			 u32 ah_signal_type);
 void ath9k_hw_set_gpio(struct ath_hw *ah, u32 gpio, u32 val);
+void ath9k_hw_request_gpio(struct ath_hw *ah, u32 gpio, const char *label);
 void ath9k_hw_setantenna(struct ath_hw *ah, u32 antenna);
 
 /* General Operation */
--- a/drivers/net/wireless/ath/ath9k/main.c
+++ b/drivers/net/wireless/ath/ath9k/main.c
@@ -719,10 +719,10 @@ static int ath9k_start(struct ieee80211_
 		ah->reset_power_on = false;
 
 	if (ah->led_pin >= 0) {
+		ath9k_hw_cfg_output(ah, ah->led_pin,
+				    AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
 		ath9k_hw_set_gpio(ah, ah->led_pin,
 				  (ah->config.led_active_high) ? 1 : 0);
-		ath9k_hw_gpio_request_out(ah, ah->led_pin, NULL,
-					  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
 	}
 
 	/*
@@ -870,7 +870,7 @@ static void ath9k_stop(struct ieee80211_
 	if (ah->led_pin >= 0) {
 		ath9k_hw_set_gpio(ah, ah->led_pin,
 				  (ah->config.led_active_high) ? 0 : 1);
-		ath9k_hw_gpio_request_in(ah, ah->led_pin, NULL);
+		ath9k_hw_cfg_gpio_input(ah, ah->led_pin);
 	}
 
 	ath_prepare_reset(sc);
